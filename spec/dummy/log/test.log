Connecting to database specified by database.yml
Connecting to database specified by database.yml
Connecting to database specified by database.yml
Connecting to database specified by database.yml
Connecting to database specified by database.yml
ActiveRecord::JDBCError: query does not return ResultSet: PRAGMA table_info("atom_smasher_feeds")
Connecting to database specified by database.yml
ActiveRecord::JDBCError: query does not return ResultSet: PRAGMA table_info("atom_smasher_feeds")
Connecting to database specified by database.yml
ActiveRecord::JDBCError: query does not return ResultSet: PRAGMA table_info("atom_smasher_feeds")
Connecting to database specified by database.yml
  [1m[36m (10.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (1.0ms)[0m  SELECT sqlite_version(*)
  [1m[36m (13.0ms)[0m  [1mCREATE TABLE "schema_migrations" ("version" varchar(255) NOT NULL) [0m
  [1m[35m (3.0ms)[0m  SELECT name, sql FROM sqlite_master WHERE tbl_name = "schema_migrations" AND type = 'index'
  [1m[36m (9.0ms)[0m  [1mCREATE UNIQUE INDEX "unique_schema_migrations" ON "schema_migrations" ("version")[0m
  [1m[35m (2.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_info"
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (2.0ms)[0m  SELECT "schema_migrations"."version" FROM "schema_migrations" 
Migrating to CreateAtomSmasherFeeds (20130403174525)
  [1m[36m (17.0ms)[0m  [1mCREATE TABLE "atom_smasher_feeds" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "url" varchar(255), "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) [0m
  [1m[35m (3.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130403174525')
Migrating to CreateAtomSmasherPosts (20130403191447)
  [1m[36m (13.0ms)[0m  [1mCREATE TABLE "atom_smasher_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "feed_id" integer, "content" text, "title" varchar(255), "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) [0m
  [1m[35m (3.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130403191447')
Migrating to AddLinkToAtomSmasherPosts (20130404120536)
  [1m[36m (17.0ms)[0m  [1mALTER TABLE "atom_smasher_posts" ADD "link" varchar(255)[0m
  [1m[35m (4.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130404120536')
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (2.0ms)[0m  SELECT "schema_migrations"."version" FROM "schema_migrations" 
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence'[0m
  [1m[35m (5.0ms)[0m  SELECT name, sql FROM sqlite_master WHERE tbl_name = "atom_smasher_feeds" AND type = 'index'
  [1m[36m (4.0ms)[0m  [1mSELECT name, sql FROM sqlite_master WHERE tbl_name = "atom_smasher_posts" AND type = 'index'[0m
Connecting to database specified by database.yml
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 02:16:46.068000', '2013-04-08 02:16:46.068000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (5.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (7.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (16.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 02:16:54.851000', 1, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 02:16:54.851000')
  [1m[36mSQL (11.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:16:54.895000', 1, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:16:54.895000')[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:16:54.962000', 1, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:16:54.962000')
  [1m[36mSQL (7.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:16:55.021000', 1, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:16:55.021000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:16:55.060000', 1, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:16:55.060000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:16:55.101000', 1, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:16:55.101000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:16:55.125000', 1, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:16:55.125000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:16:55.171000', 1, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:16:55.171000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:16:55.207000', 1, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:16:55.207000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:16:55.243000', 1, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:16:55.243000')[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 1[0m
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 02:17:55.809000', '2013-04-08 02:17:55.809000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (4.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (12.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (18.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:18:03.463000', 2, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:18:03.463000')[0m
  [1m[35mSQL (19.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:18:03.515000', 2, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:18:03.515000')
  [1m[36mSQL (23.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:18:03.554000', 2, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:18:03.554000')[0m
  [1m[35mSQL (20.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:18:03.660000', 2, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:18:03.660000')
  [1m[36mSQL (14.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:18:03.716000', 2, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:18:03.716000')[0m
  [1m[35mSQL (18.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:18:03.762000', 2, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:18:03.762000')
  [1m[36mSQL (25.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:18:03.820000', 2, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:18:03.820000')[0m
  [1m[35mSQL (23.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:18:03.883000', 2, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:18:03.883000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:18:03.947000', 2, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:18:03.947000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 2[0m
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 02:19:13.427000', '2013-04-08 02:19:13.427000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (4.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (28.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (20.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:19:22.313000', 3, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:19:22.313000')[0m
  [1m[35mSQL (18.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:19:22.378000', 3, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:19:22.378000')
  [1m[36mSQL (23.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:19:22.422000', 3, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:19:22.422000')[0m
  [1m[35mSQL (22.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:19:22.509000', 3, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:19:22.509000')
  [1m[36mSQL (9.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:19:22.584000', 3, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:19:22.584000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:19:22.640000', 3, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:19:22.640000')
  [1m[36mSQL (11.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:19:22.701000', 3, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:19:22.701000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:19:22.744000', 3, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:19:22.744000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:19:22.803000', 3, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:19:22.803000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 3[0m
Connecting to database specified by database.yml
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (8.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 02:20:33.250000', '2013-04-08 02:20:33.250000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (4.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (24.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:20:40.399000', 4, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:20:40.399000')[0m
  [1m[35mSQL (18.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:20:40.472000', 4, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:20:40.472000')
  [1m[36mSQL (24.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:20:40.521000', 4, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:20:40.521000')[0m
  [1m[35mSQL (21.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:20:40.647000', 4, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:20:40.647000')
  [1m[36mSQL (9.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:20:40.706000', 4, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:20:40.706000')[0m
  [1m[35mSQL (10.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:20:40.758000', 4, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:20:40.758000')
  [1m[36mSQL (14.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:20:40.853000', 4, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:20:40.853000')[0m
  [1m[35mSQL (9.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:20:40.920000', 4, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:20:40.920000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:20:40.989000', 4, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:20:40.989000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4[0m
  [1m[35mAtomSmasher::Feed Load (8.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:20:46.376000', 4, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:20:46.376000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:20:46.408000', 4, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:20:46.408000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:20:46.442000', 4, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:20:46.442000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:20:46.468000', 4, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:20:46.468000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:20:46.490000', 4, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:20:46.490000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:20:46.513000', 4, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:20:46.513000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:20:46.538000', 4, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:20:46.538000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:20:46.566000', 4, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:20:46.566000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:20:46.618000', 4, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:20:46.618000')[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (2.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35m (2.0ms)[0m  UPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 02:20:46.720000' WHERE "atom_smasher_feeds"."id" = 4
  [1m[36m (0.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35mAtomSmasher::Feed Load (3.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (9.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (8.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 02:20:47.821000', 4, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 02:20:47.821000')
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (2.0ms)[0m  SELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 4
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 02:35:45.157000', '2013-04-08 02:35:45.157000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (6.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (4.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (9.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (16.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (22.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:35:57.012000', 5, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:35:57.012000')[0m
  [1m[35mSQL (25.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:35:57.078000', 5, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:35:57.078000')
  [1m[36mSQL (31.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:35:57.140000', 5, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:35:57.140000')[0m
  [1m[35mSQL (8.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:35:57.383000', 5, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:35:57.383000')
  [1m[36mSQL (7.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:35:57.458000', 5, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:35:57.458000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:35:57.529000', 5, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:35:57.529000')
  [1m[36mSQL (13.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:35:57.612000', 5, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:35:57.612000')[0m
  [1m[35mSQL (14.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:35:57.659000', 5, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:35:57.659000')
  [1m[36mSQL (32.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:35:57.749000', 5, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:35:57.749000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5[0m
  [1m[35mAtomSmasher::Feed Load (6.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (20.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:36:05.096000', 5, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:36:05.096000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:36:05.127000', 5, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:36:05.127000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:36:05.166000', 5, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:36:05.166000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:36:05.205000', 5, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:36:05.205000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:36:05.229000', 5, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:36:05.229000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:36:05.258000', 5, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:36:05.258000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:36:05.291000', 5, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:36:05.291000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:36:05.314000', 5, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:36:05.314000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:36:05.331000', 5, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:36:05.331000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (6.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (8.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (0.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:36:10.791000', 5, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:36:10.791000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:36:10.840000', 5, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:36:10.840000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:36:10.862000', 5, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:36:10.862000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:36:10.898000', 5, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:36:10.898000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:36:10.927000', 5, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:36:10.927000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:36:10.953000', 5, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:36:10.953000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:36:10.981000', 5, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:36:10.981000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:36:11.027000', 5, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:36:11.027000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:36:11.052000', 5, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:36:11.052000')
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mUPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 02:36:11.082000' WHERE "atom_smasher_feeds"."id" = 5[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1
  [1m[36mAtomSmasher::Post Load (8.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 02:36:11.793000', 5, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 02:36:11.793000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 5[0m
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 02:36:46.220000', '2013-04-08 02:36:46.220000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (3.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (8.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (18.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:36:54.658000', 6, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:36:54.658000')[0m
  [1m[35mSQL (17.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:36:54.717000', 6, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:36:54.717000')
  [1m[36mSQL (23.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:36:54.754000', 6, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:36:54.754000')[0m
  [1m[35mSQL (25.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:36:54.827000', 6, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:36:54.827000')
  [1m[36mSQL (15.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:36:54.895000', 6, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:36:54.895000')[0m
  [1m[35mSQL (19.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:36:54.945000', 6, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:36:54.945000')
  [1m[36mSQL (24.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:36:55.002000', 6, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:36:55.002000')[0m
  [1m[35mSQL (19.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:36:55.052000', 6, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:36:55.052000')
  [1m[36mSQL (20.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:36:55.123000', 6, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:36:55.123000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6[0m
  [1m[35mAtomSmasher::Feed Load (5.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:37:02.155000', 6, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:37:02.155000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:37:02.199000', 6, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:37:02.199000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:37:02.258000', 6, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:37:02.258000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:37:02.285000', 6, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:37:02.285000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:37:02.309000', 6, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:37:02.309000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:37:02.329000', 6, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:37:02.329000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:37:02.355000', 6, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:37:02.355000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:37:02.374000', 6, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:37:02.374000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:37:02.391000', 6, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:37:02.391000')[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (3.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (8.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (2.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:37:07.611000', 6, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:37:07.611000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:37:07.648000', 6, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:37:07.648000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:37:07.667000', 6, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:37:07.667000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:37:07.702000', 6, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:37:07.702000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:37:07.733000', 6, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:37:07.733000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:37:07.761000', 6, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:37:07.761000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:37:07.784000', 6, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:37:07.784000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:37:07.829000', 6, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:37:07.829000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:37:07.853000', 6, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:37:07.853000')
  [1m[36m (0.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36m (2.0ms)[0m  [1mUPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 02:37:07.884000' WHERE "atom_smasher_feeds"."id" = 6[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (2.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 02:37:08.441000', 6, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 02:37:08.441000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 6 ORDER BY "atom_smasher_posts"."id" DESC LIMIT 1
Connecting to database specified by database.yml
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (8.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 02:38:15.756000', '2013-04-08 02:38:15.756000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (4.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (17.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:38:23.151000', 7, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:38:23.151000')[0m
  [1m[35mSQL (16.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:38:23.211000', 7, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:38:23.211000')
  [1m[36mSQL (14.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:38:23.246000', 7, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:38:23.246000')[0m
  [1m[35mSQL (56.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:38:23.311000', 7, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:38:23.311000')
  [1m[36mSQL (19.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:38:23.416000', 7, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:38:23.416000')[0m
  [1m[35mSQL (17.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:38:23.484000', 7, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:38:23.484000')
  [1m[36mSQL (19.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:38:23.542000', 7, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:38:23.542000')[0m
  [1m[35mSQL (8.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:38:23.590000', 7, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:38:23.590000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:38:23.654000', 7, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:38:23.654000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (5.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (15.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (0.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:38:29.213000', 7, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:38:29.213000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:38:29.245000', 7, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:38:29.245000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:38:29.284000', 7, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:38:29.284000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:38:29.307000', 7, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:38:29.307000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:38:29.326000', 7, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:38:29.326000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:38:29.347000', 7, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:38:29.347000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:38:29.375000', 7, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:38:29.375000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:38:29.398000', 7, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:38:29.398000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:38:29.431000', 7, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:38:29.431000')
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (3.0ms)[0m  SELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7
  [1m[36mAtomSmasher::Feed Load (3.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (0.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:38:34.851000', 7, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:38:34.851000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:38:34.896000', 7, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:38:34.896000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:38:34.920000', 7, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:38:34.920000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:38:34.956000', 7, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:38:34.956000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:38:34.993000', 7, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:38:34.993000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:38:35.023000', 7, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:38:35.023000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:38:35.049000', 7, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:38:35.049000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:38:35.100000', 7, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:38:35.100000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:38:35.128000', 7, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:38:35.128000')
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mUPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 02:38:35.159000' WHERE "atom_smasher_feeds"."id" = 7[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (2.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 02:38:35.767000', 7, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 02:38:35.767000')[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (5.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 7 ORDER BY "atom_smasher_posts"."id" DESC LIMIT 1
Connecting to database specified by database.yml
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 02:40:15.070000', '2013-04-08 02:40:15.070000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (26.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (5.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (18.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:40:23.966000', 8, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:40:23.966000')[0m
  [1m[35mSQL (14.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:40:24.023000', 8, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:40:24.023000')
  [1m[36mSQL (9.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:40:24.052000', 8, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:40:24.052000')[0m
  [1m[35mSQL (7.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:40:24.118000', 8, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:40:24.118000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:40:24.157000', 8, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:40:24.157000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:40:24.218000', 8, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:40:24.218000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:40:24.260000', 8, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:40:24.260000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:40:24.287000', 8, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:40:24.287000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:40:24.407000', 8, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:40:24.407000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35m (3.0ms)[0m  UPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 02:40:24.444000' WHERE "atom_smasher_feeds"."id" = 8
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35mAtomSmasher::Feed Load (4.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (20.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 02:40:25.353000', 8, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 02:40:25.353000')
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (4.0ms)[0m  SELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 ORDER BY "atom_smasher_posts"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Feed Load (5.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (2.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (7.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:40:31.376000', 8, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:40:31.376000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:40:31.496000', 8, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:40:31.496000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:40:31.533000', 8, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:40:31.533000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:40:31.622000', 8, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:40:31.622000')
  [1m[36mSQL (8.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:40:31.673000', 8, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:40:31.673000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:40:31.715000', 8, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:40:31.715000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:40:31.738000', 8, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:40:31.738000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:40:31.772000', 8, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:40:31.772000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:40:31.804000', 8, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:40:31.804000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8[0m
  [1m[35mAtomSmasher::Feed Load (4.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 8 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 02:40:37.589000', 8, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 02:40:37.589000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 02:40:37.616000', 8, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 02:40:37.616000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 02:40:37.638000', 8, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 02:40:37.638000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 02:40:37.662000', 8, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 02:40:37.662000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 02:40:37.680000', 8, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 02:40:37.680000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 02:40:37.723000', 8, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 02:40:37.723000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 02:40:37.748000', 8, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 02:40:37.748000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 02:40:37.776000', 8, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 02:40:37.776000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 02:40:37.804000', 8, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 02:40:37.804000')[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:27:05.431000', '2013-04-08 13:27:05.431000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (6.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (26.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:27:16.951000', 9, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:27:16.951000')[0m
  [1m[35mSQL (19.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:27:17.018000', 9, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:27:17.018000')
  [1m[36mSQL (21.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:27:17.071000', 9, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:27:17.071000')[0m
  [1m[35mSQL (33.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:27:17.169000', 9, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:27:17.169000')
  [1m[36mSQL (19.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:27:17.253000', 9, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:27:17.253000')[0m
  [1m[35mSQL (35.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:27:17.314000', 9, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:27:17.314000')
  [1m[36mSQL (32.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:27:17.410000', 9, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:27:17.410000')[0m
  [1m[35mSQL (7.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:27:17.495000', 9, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:27:17.495000')
  [1m[36mSQL (7.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:27:17.552000', 9, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:27:17.552000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9[0m
  [1m[35mAtomSmasher::Feed Load (5.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:27:23.295000', 9, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:27:23.295000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:27:23.320000', 9, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:27:23.320000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:27:23.354000', 9, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:27:23.354000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:27:23.379000', 9, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:27:23.379000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:27:23.405000', 9, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:27:23.405000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:27:23.429000', 9, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:27:23.429000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:27:23.453000', 9, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:27:23.453000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:27:23.470000', 9, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:27:23.470000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:27:23.488000', 9, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:27:23.488000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35m (3.0ms)[0m  UPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 13:27:23.576000' WHERE "atom_smasher_feeds"."id" = 9
  [1m[36m (0.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35mAtomSmasher::Feed Load (3.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 13:27:24.370000', 9, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 13:27:24.370000')
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (4.0ms)[0m  SELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 ORDER BY "atom_smasher_posts"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Feed Load (5.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 9 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:27:30.223000', 9, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:27:30.223000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:27:30.253000', 9, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:27:30.253000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:27:30.276000', 9, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:27:30.276000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:27:30.298000', 9, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:27:30.298000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:27:30.317000', 9, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:27:30.317000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:27:30.361000', 9, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:27:30.361000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:27:30.384000', 9, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:27:30.384000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:27:30.411000', 9, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:27:30.411000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:27:30.439000', 9, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:27:30.439000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
Connecting to database specified by database.yml
  [1m[36m (20.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (4.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"
  [1m[36m (2.0ms)[0m  [1mSELECT "schema_migrations"."version" FROM "schema_migrations" [0m
Migrating to CreateUsers (20130408132820)
  [1m[35m (1.0ms)[0m  SELECT sqlite_version(*)
  [1m[36m (11.0ms)[0m  [1mCREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(255), "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) [0m
  [1m[35m (3.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130408132820')
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (2.0ms)[0m  SELECT "schema_migrations"."version" FROM "schema_migrations" 
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence'[0m
  [1m[35m (3.0ms)[0m  SELECT name, sql FROM sqlite_master WHERE tbl_name = "atom_smasher_feeds" AND type = 'index'
  [1m[36m (3.0ms)[0m  [1mSELECT name, sql FROM sqlite_master WHERE tbl_name = "atom_smasher_posts" AND type = 'index'[0m
  [1m[35m (3.0ms)[0m  SELECT name, sql FROM sqlite_master WHERE tbl_name = "users" AND type = 'index'
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (106.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:36:45.334000', '2013-04-08 13:36:45.334000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (3.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (9.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (19.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:36:57.793000', 10, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:36:57.793000')[0m
  [1m[35mSQL (12.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:36:57.855000', 10, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:36:57.855000')
  [1m[36mSQL (21.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:36:57.885000', 10, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:36:57.885000')[0m
  [1m[35mSQL (24.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:36:57.957000', 10, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:36:57.957000')
  [1m[36mSQL (19.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:36:58.023000', 10, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:36:58.023000')[0m
  [1m[35mSQL (19.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:36:58.079000', 10, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:36:58.079000')
  [1m[36mSQL (18.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:36:58.145000', 10, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:36:58.145000')[0m
  [1m[35mSQL (11.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:36:58.196000', 10, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:36:58.196000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:36:58.254000', 10, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:36:58.254000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10[0m
  [1m[35mAtomSmasher::Feed Load (3.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:37:04.277000', 10, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:37:04.277000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:37:04.308000', 10, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:37:04.308000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:37:04.350000', 10, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:37:04.350000')[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:37:04.411000', 10, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:37:04.411000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:37:04.439000', 10, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:37:04.439000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:37:04.469000', 10, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:37:04.469000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:37:04.501000', 10, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:37:04.501000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:37:04.519000', 10, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:37:04.519000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:37:04.542000', 10, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:37:04.542000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (3.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (10.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (0.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:37:11.058000', 10, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:37:11.058000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:37:11.119000', 10, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:37:11.119000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:37:11.164000', 10, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:37:11.164000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:37:11.210000', 10, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:37:11.210000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:37:11.311000', 10, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:37:11.311000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:37:11.346000', 10, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:37:11.346000')[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:37:11.378000', 10, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:37:11.378000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:37:11.455000', 10, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:37:11.455000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:37:11.493000', 10, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:37:11.493000')
  [1m[36m (0.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mUPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 13:37:11.539000' WHERE "atom_smasher_feeds"."id" = 10[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (2.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (12.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 13:37:12.310000', 10, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 13:37:12.310000')[0m
  [1m[35m (2.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 10 ORDER BY "atom_smasher_posts"."id" DESC LIMIT 1
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (7.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:37:53.019000', '2013-04-08 13:37:53.019000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (6.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (5.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (17.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:38:01.703000', 11, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:38:01.703000')[0m
  [1m[35mSQL (14.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:38:01.760000', 11, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:38:01.760000')
  [1m[36mSQL (17.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:38:01.799000', 11, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:38:01.799000')[0m
  [1m[35mSQL (23.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:38:01.870000', 11, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:38:01.870000')
  [1m[36mSQL (18.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:38:01.951000', 11, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:38:01.951000')[0m
  [1m[35mSQL (19.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:38:02.007000', 11, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:38:02.007000')
  [1m[36mSQL (24.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:38:02.081000', 11, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:38:02.081000')[0m
  [1m[35mSQL (17.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:38:02.135000', 11, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:38:02.135000')
  [1m[36mSQL (14.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:38:02.195000', 11, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:38:02.195000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (5.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (10.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:38:08.966000', 11, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:38:08.966000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:38:09.003000', 11, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:38:09.003000')[0m
  [1m[35mSQL (8.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:38:09.060000', 11, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:38:09.060000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:38:09.095000', 11, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:38:09.095000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:38:09.123000', 11, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:38:09.123000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:38:09.144000', 11, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:38:09.144000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:38:09.173000', 11, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:38:09.173000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:38:09.199000', 11, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:38:09.199000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:38:09.222000', 11, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:38:09.222000')
  [1m[36m (0.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mUPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 13:38:09.283000' WHERE "atom_smasher_feeds"."id" = 11[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (3.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (7.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1
  [1m[36mAtomSmasher::Post Load (9.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 13:38:10.596000', 11, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 13:38:10.596000')[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 ORDER BY "atom_smasher_posts"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (0.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:38:17.876000', 11, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:38:17.876000')
  [1m[36mSQL (2.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:38:17.907000', 11, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:38:17.907000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:38:17.929000', 11, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:38:17.929000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:38:17.974000', 11, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:38:17.974000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:38:17.993000', 11, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:38:17.993000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:38:18.035000', 11, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:38:18.035000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:38:18.060000', 11, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:38:18.060000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:38:18.087000', 11, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:38:18.087000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:38:18.104000', 11, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:38:18.104000')
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (2.0ms)[0m  SELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 11
Connecting to database specified by database.yml
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:39:14.984000', '2013-04-08 13:39:14.984000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (4.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (24.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (25.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:39:24.202000', 12, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:39:24.202000')[0m
  [1m[35mSQL (19.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:39:24.423000', 12, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:39:24.423000')
  [1m[36mSQL (26.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:39:24.465000', 12, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:39:24.465000')[0m
  [1m[35mSQL (11.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:39:24.610000', 12, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:39:24.610000')
  [1m[36mSQL (8.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:39:24.666000', 12, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:39:24.666000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:39:24.739000', 12, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:39:24.739000')
  [1m[36mSQL (8.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:39:24.819000', 12, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:39:24.819000')[0m
  [1m[35mSQL (33.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:39:24.849000', 12, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:39:24.849000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:39:24.987000', 12, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:39:24.987000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12[0m
  [1m[35mAtomSmasher::Feed Load (4.0ms)[0m  SELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (9.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (12.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:39:31.639000', 12, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:39:31.639000')[0m
  [1m[35mSQL (2.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:39:31.665000', 12, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:39:31.665000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:39:31.700000', 12, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:39:31.700000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:39:31.719000', 12, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:39:31.719000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:39:31.737000', 12, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:39:31.737000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:39:31.759000', 12, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:39:31.759000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:39:31.783000', 12, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:39:31.783000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:39:31.801000', 12, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:39:31.801000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:39:31.839000', 12, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:39:31.839000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (3.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (2.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (0.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:39:38.074000', 12, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:39:38.074000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:39:38.114000', 12, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:39:38.114000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:39:38.135000', 12, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:39:38.135000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:39:38.197000', 12, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:39:38.197000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:39:38.232000', 12, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:39:38.232000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:39:38.265000', 12, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:39:38.265000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:39:38.291000', 12, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:39:38.291000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:39:38.345000', 12, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:39:38.345000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:39:38.381000', 12, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:39:38.381000')
  [1m[36m (1.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mUPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 13:39:38.420000' WHERE "atom_smasher_feeds"."id" = 12[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (8.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1
  [1m[36mAtomSmasher::Post Load (7.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 13:39:39.610000', 12, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 13:39:39.610000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (3.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 12 ORDER BY "atom_smasher_posts"."id" DESC LIMIT 1
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (9.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:40:10.159000', '2013-04-08 13:40:10.159000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35m (11.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_posts"
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1
  [1m[36mAtomSmasher::Post Load (4.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (19.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:40:19.892000', 13, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:40:19.892000')[0m
  [1m[35mSQL (10.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:40:19.953000', 13, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:40:19.953000')
  [1m[36mSQL (6.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:40:19.982000', 13, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:40:19.982000')[0m
  [1m[35mSQL (7.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:40:20.063000', 13, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:40:20.063000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:40:20.113000', 13, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:40:20.113000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:40:20.148000', 13, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:40:20.148000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:40:20.218000', 13, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:40:20.218000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:40:20.262000', 13, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:40:20.262000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:40:20.305000', 13, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:40:20.305000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (27.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (1.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:40:26.477000', 13, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:40:26.477000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:40:26.507000', 13, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:40:26.507000')[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:40:26.547000', 13, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:40:26.547000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:40:26.580000', 13, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:40:26.580000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:40:26.604000', 13, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:40:26.604000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:40:26.632000', 13, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:40:26.632000')[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:40:26.665000', 13, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:40:26.665000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:40:26.687000', 13, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:40:26.687000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:40:26.706000', 13, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:40:26.706000')
  [1m[36m (0.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (23.0ms)[0m  SELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13
  [1m[36mAtomSmasher::Feed Load (4.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/390-turbolinks' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/387-cache-digests' LIMIT 1
  [1m[36mAtomSmasher::Post Load (5.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/340-datatables' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/338-globalize3' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/336-copycopter' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (4.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/334-compass-css-sprites' LIMIT 1
  [1m[36mAtomSmasher::Post Load (3.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/332-refinery-cms-basics' LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (3.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/330-better-sass-with-bourbon' LIMIT 1
  [1m[36m (0.0ms)[0m  [1mSAVEPOINT active_record_1[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 393:¬†Guest User Record¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Let‚Äôs say that we have a to-do list application where the user can add tasks and mark them as complete. A task list is private for a user which means that a new user must first sign up for the app before they can try it out.
This is the page that a new user sees when they first visit the app with a description to try to convince them to try it. When they click the ‚ÄúTry it for free‚Äù button they see a sign-up form and at this point a lot of potential customers will leave as they won‚Äôt want to give their personal information just to try out an app. What can we do to improve this user experience? Instead of redirecting new users to a sign-up form we‚Äôll create a temporary guest account that they can use to try the application. Later on they can sign up for a permanent account if they like it.
Handling Guest Users
The first question that comes to mind is should we store the guest user account in the database if it‚Äôs just temporary? Our application is currently structured so that a user has many tasks and we use this association in the TasksController to ensure that only the current user‚Äôs tasks are shown. While we could keep track of a guest‚Äôs tasks‚Äô ids in a session this could get messy as our application grows and we have other associations with out User record. This would also mean that we had a lot of user_id foreign keys in our database that will be null and we‚Äôd have no way then of knowing if two tasks are shared by the same guest user and so on. Given all this we‚Äôll keep track of all the guests in the database and to start we‚Äôll add a boolean guest column to the users table.
 
 $ rails g migration add_guest_to_users guest:boolean
$ rake db:migrate
Now we need to modify our application so that when a user clicks the ‚ÄúTry it for free‚Äù button a new guest user account is automatically created for them. The button currently redirects the user to the new_users_path so that the form is displayed, but instead we‚Äôll point it to the users_path with a POST action. 
 /app/views/tasks/index.html.erb
 &lt;%= button_to "Try it for free!", users_path, method: :post %&gt;
Clicking this button now triggers the UsersController‚Äôs create action. This is currently set up to accept parameters from a form and we‚Äôll modify it so that if no parameters are passed in a new guest user is created, using a new new_guest class method on the User model.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
In our User model we‚Äôve written the authentication from scratch as we showed in episode 250. We use has_secure_password which Rails provides and which is a convenient way to add authentication to an application. If you‚Äôre using Devise or another authentication gem you‚Äôll need to alter the technique we use here.
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email
 validates_uniqueness_of :username
 has_secure_password
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
In the new_guest method we create a new User and set its guest attribute to true. We do this inside a block because the guest attribute is protected from mass-assignment.
A guest user will now be created whenever we click that button, but what if we want this to work a little differently? Maybe we don‚Äôt want to override the UsersController‚Äôs create method or we want a guest user to always be available if we try to access the current user when one isn‚Äôt logged in. In these cases we can override the current_user method in the ApplicationController and have it fall back to creating a guest user if there is no current user_id session variable. We won‚Äôt take that approach here but it‚Äôs worth considering as a way to handle guest users.
Dealing With Validations
Let‚Äôs try our changes out. When we visit the home page then click the ‚ÄúTry it for free‚Äù button the UsersController attempts to create a guest user but that user fails the validation and so we‚Äôre redirected to the sign-up form.
What we need is for the new_guest method to return a valid user record and there are multiple ways that we can do this. One option is to add fake data for the required fields so that the validation passes. This is certainly an option but if we have different authentication techniques, such as signing in through Twitter it‚Äôs harder to fake this data. This approach also means that we‚Äôre filling up the database with data that will never be used. Instead, we‚Äôll modify the validations so that they‚Äôre conditional and not required if the current user is a guest.
 /app/models/user.rb
 validates_presence_of :username, :email, unless: :guest?
validates_uniqueness_of :username, allow_blank: true
When we click the button now the validations still fail as we haven‚Äôt supplied a password. This validation is added automatically by has_secure_password. In Rails 4 we‚Äôll be able to pass in a validations option and set it to false so that these validations are skipped and then set them manually. Unfortunately this isn‚Äôt available in Rails 3 but the implementation for has_secure_password is surprisingly simple. The method is only around a dozen lines long and most of the logic is contained in a module called InstanceMethodsOnActivation which we can easily include manually. We can mimic this functionality and alter it to suit our needs. Once we‚Äôve done that out model class looks like this:
 /app/models/user.rb
 class User &lt; ActiveRecord::Base
 has_many :tasks
 attr_accessible :username, :email, :password, :password_confirmation
 validates_presence_of :username, :email, :password_digest, unless: :guest?
 validates_uniqueness_of :username, allow_blank: true
 validates_confirmation_of :password
 # override has_secure_password to customize validation until Rails 4.
 require ''bcrypt''
 attr_reader :password
 include ActiveModel::SecurePassword::InstanceMethodsOnActivation
 
 def self.new_guest
 new { |u| u.guest = true }
 end
end
Our class now mimics the functionality of has_secure_password but without the validations. This means that we can manually add the validations we want instead. If you‚Äôre using Devise and want to do something similar to this you can remove the Validatable module and add the validations manually or alternatively we can remove the email_changed? and password_required? methods so that they‚Äôre dependent on whether the current user is a guest. 
We can try our application out now. If we click ‚ÄúTry it for free‚Äù now we‚Äôre taken to the home page and we can add items and mark them as complete without having created a user account.
There are still some minor issues with our application. For example the login status text says ‚ÄúLogged in as .‚Äù. We should instead give an indication that they‚Äôre logged in as a guest user and give them the chance to sign up for full membership. We can do this by editing the application‚Äôs layout file. This currently displays the current user‚Äôs username. We‚Äôll display the name instead, which is a new method on the User model that we‚Äôll write shortly.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;%= link_to "Log Out", logout_path %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
The new name method will check if the current user is a guest and, if so, display ‚ÄúGuest‚Äù instead of their username.
 /app/models/user.rb
 def name
 guest ? "Guest" : username
end
Now we need a way for guests to sign up and we‚Äôll do this by adding a link to the layout that only shows if they‚Äôre a guest.
 /app/views/layouts/application.html.erb
 &lt;% if current_user %&gt;
 Logged in as &lt;%= current_user.name %&gt;.
 &lt;% if current.user.guest? %&gt;
 &lt;%= link_to "Become a member", signup_path %&gt;
 &lt;% else %&gt;
 &lt;%= link_to "Log Out", logout_path %&gt;
 &lt;% end %&gt;
&lt;% else %&gt;
 &lt;%= link_to "Log In", login_path %&gt;
&lt;% end %&gt;
We could make a logout link for guests too but we‚Äôd need to be a little more careful about that as guests can‚Äôt log back in. 
Storing Guest Users‚Äô Tasks
The trickiest part of all this is that we need to persist a guest user‚Äôs tasks when they become a member. There are several different ways that we can do this. One option is to change the create action so that it updates the current user record and removes the guest flag instead of creating a new record. Trying to juggle both new and existing user records in the same action can get a little messy, however, so we won‚Äôt try this. Instead we‚Äôll move the associated data from the current user to the newly-created user if a current user exists and they are a guest.
 /app/controllers/users_controller.rb
 def create
 @user = params[:user] ? User.new(params[:user]) : User.new_guest
 if @user.save
 current_user.move_to(@user) if current_user &amp;&amp; current.user.guest?
 session[:user_id] = @user.id
 redirect_to root_url
 else
 render "new"
 end
end
We call a move_to method on the User model to move the data while we‚Äôll need to write. This will go through all the different associations and call update_all on them setting the user_id to the new user‚Äôs id.
 /app/models/user.rb
 def move_to(user)
 tasks.update_all(user_id: user.id)
end
We could also destroy the guest user here but we need to be careful if we do this as it might still have the associations still tied to it. For example if a user has many tasks and dependent is set to destroy this will end up destroying the tasks it‚Äôs associated with even though we‚Äôve updated them to the new user. A better solution is to create a Rake task to destroy old guest accounts. This could look like this:
 /lib/tasks/guests.rake
 namespace :guests do
 desc "Remove guest accounts more than a week old."
 task :cleanup =&gt; :environment do
 User.where(guest: :true).where("created_at &lt; ?", 1.week.ago).destroy_all
 end
end
The Rake task will go through all the User records and destroy all the guest accounts that were created over a week ago. If we do this it would be a good idea to notify the guest users that their accounts will be deleted after a week unless they upgrade to a full account. To have old guest accounts deleted automatically we could set up this Rake task as a cron job using the Whenever gem as demonstrated in episode 164. Now when a guest user clicks ‚ÄúBecome a member‚Äù and fills in the signup form all their tasks are automatically moved over to their new account.
 
 
</div>', '2013-04-08 13:40:32.624000', 13, 'http://asciicasts.com/episodes/393-guest-user-record', 'Guest User Record', '2013-04-08 13:40:32.624000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 390:¬†Turbolinks¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Turbolinks is a gem that will be included by default in new Rails 4 applications. It‚Äôs also compatible with Rails 3 so we can use it in our current apps too. This gem can make our applications appear faster to the user by using JavaScript to replace the HTML body of new pages instead of relying on a full page load. In this episode we‚Äôll try this gem out in a Rails 3 app. The application we‚Äôll be using is a Todo-list application that handles multiple projects, each of which can have a set of tasks. New tasks start off being marked as incomplete but we can mark them as completed by checking the checkbox next to each item.
Adding Turbolinks
We‚Äôll add Turbolinks to this application to see how it works. First we‚Äôll add it to the list of gems in the gemfile then run bundle to install it.
 /Gemfile
 gem ''turbolinks''
Next we‚Äôll go into our application‚Äôs Javascript manifest file and add a line to require turbolinks. Turbolinks doesn‚Äôt depend on jQuery so we can use it even if we don‚Äôt use jQuery in our application.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
If we restart our Rails application now we can browse around it like before although we won‚Äôt notice much difference when we do. We can check to see if Turbolinks is active by opening the network inspector and then clicking around the site. When we do this it seems that a full page reload is happening each time we click a links and so Turbolinks isn‚Äôt active. This could be because the browser we‚Äôre using isn‚Äôt supported by Turbolinks and so we could upgrade it or use a different one. Turbolinks expects a recent browser but if it isn‚Äôt supported then it will degrade gracefully and our app will still work like we expect it to. Instead let‚Äôs try viewing our page again in a recent version of Chrome. When we do we‚Äôll see that when we click a link now the page isn‚Äôt fully reloaded. Instead an AJAX request is made for the next page by the turbolinks.js file.
This can make the site feel faster to the user as the browser isn‚Äôt reinterpreting the JavaScript and CSS each time the page loads but how does it work? What Turbolinks does is listen to click events for each link on the page. When one of these fires the request is made by JavaScript and Turbolinks will look at the response‚Äôs body. It then uses JavaScript to update the current page with this new content, replacing the title and body elements so that it looks like the new page. It also uses the Push State API to modify the URL so that of the new page. This technique is very similar to PJAX, which was covered in episode 294.
Issues With Existing JavaScript Functionality
Our application appears to be working well with Turbolinks but we might find that some of our existing JavaScript stops working. For example, if we try to update a task to mark it as complete now nothing happens. If we reload the current page and check the checkbox again, however, it will work. The CoffeeScript code for this page looks like this:
 /app/assets/javascripts/projects.js.coffee
 jQuery -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
This code listens for the click event for each of the tasks‚Äô checkboxes. When one is clicked, the form that contains the checkbox is submitted and the task is marked as complete. The important line in this code is the first one, which calls the jQuery function. This code listens for the ready event on the document which is triggered when the page‚Äôs DOM has finished loading. If we didn‚Äôt wrap the rest of the code in this function then jQuery would try attaching click events to the matching checkboxes before they had loaded in.
When we use Turbolinks this callback is only triggered on the initial page load. This means that if we start on another page then move to the page for a task the DOM‚Äôs ready event isn‚Äôt fired as we‚Äôre still technically on the same HTML page. There are several events that Turbolinks will trigger, one of which is called page:load. We can use this to simulate the DOM ready behaviour in our CoffeeScript file.
 /app/assets/javascripts/projects.js.coffee
 ready = -&gt;
 $(''.edit_task input[type=checkbox]'').click -&gt;
 $(this).parent(''form'').submit()
$(document).ready(ready)
$(document).on(''page:load'', ready)
Now we set the function that checks the checkboxes to a variable called ready and pass it to both the document.ready and the page:load events. This way the events for the checkboxes will be attached whether we‚Äôve loaded the page via Turbolinks or not. With this change in place the checkboxes now work as we expect them to again and checking an incomplete task will move it to the completed list.
If we want this behaviour automatically we can use the JQuery Turbolinks gem. There is another way we can work around this problem. Instead of selecting elements and listening to their click events we can listen to the document‚Äôs click event and check to see when this event fires if the element that caused the event was the checkbox for a task.
 /app/assets/javascripts/projects.js.coffee
 $(''document'').on ''click'', ''.edit_task input[type=checkbox]'', -&gt;
 $(this).parent(''form'').submit()
This way we don‚Äôt need to fire this code on a DOM-ready event as it will fire on any checkbox that‚Äôs added to the HTML, event after this JavaScript code is executed. This approach has the additional advantage that if we add more tasks through AJAX they will automatically have this event applied to them.
It‚Äôs a good idea to keep an eye on the Turbolinks issue tracker as there are some issues that we should be aware of. There are several third-party libraries that are incompatible with Turbolinks such as Twitter Bootstrap and jQuery UI Calendar although work is in progress to make them compatible. Also there are some odd situations where reloading the page or clicking the back button in certain browsers can cause some unexpected behaviour such as submitting a POST request instead of a GET in certain circumstances. Workarounds for these issues exist that will disable Turbolinks in these situations, although they shouldn‚Äôt be needed in future versions of Turbolinks. 
With all these issues you might be wondering whether using Turbolinks is worth it. One thing that may persuade you to use it is Turbolinks Test. This runs benchmarks to see if Turbolinks gives a speed boost in certain situations and most of the time it does, reducing response time by up to a half. Of course all applications are different but it‚Äôs easy to use this with your own applications to see if it‚Äôs responsiveness is improved. 
If we create a new Rails 4 application and decide not to use Turbolinks we can easily remove it by commenting-out the gem in the gemfile and the require statement in the application‚Äôs JavaScript manifest file.
 
 
</div>', '2013-04-08 13:40:32.667000', 13, 'http://asciicasts.com/episodes/390-turbolinks', 'Turbolinks', '2013-04-08 13:40:32.667000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 387:¬†Cache Digests¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a screenshot from an example application that shows a list of projects each of which has a number of tasks. Let‚Äôs say that we‚Äôre having performance issues on this page and that we want to add fragment caching to it to speed it up.
The template for this page is shown below. This simply renders out the projects.
 /app/views/projects/index.html.erb
 Projects
&lt;%= render @projects %&gt;
For each project the _project partial is rendered. This template is also fairly simple and renders the tasks for each project.
 /app/views/projects/_project.html.erb
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
&lt;%= render project.tasks %&gt;
This partial renders the _task partial for each task that the project has.
 /app/views/tasks/_task.html.erb
 
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
We‚Äôll add fragment caching to the _projects partial. If you‚Äôre not familiar with fragment caching take a look at episode 90 which covers it in more detail.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
As we‚Äôre rendering out the tasks inside this partial it would be good if this cache expired when a task is changed. We can do this by modifying the Task model and adding touch: true to the project association.
 /app/models/task.rb
 class Task &lt; ActiveRecord::Base
 attr_accessible :name, :completed_at
 belongs_to :project, touch: true
end
Now the project that a task belongs to will be marked as updated when that task is updated. So that we can see the effects of this we‚Äôll modify the development configuration file and set perform_caching to true so that we can try this out.
 /config/development.rb
 config.action_controller.perform_caching = true
When we restart our Rails app now and then reload the home page each of the projects will be stored in a fragment cache. Each subsequent time we reload the page those parts will be read from the cache. If we edit a task the cache for that task‚Äôs project will be expired and a new one will be created.
Handling Changes to Cached Templates
This works well but what happens if we make a change to the view template? Let‚Äôs say that we want to render the tasks in an ordered list instead of an unordered list.
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
When we reload the page we won‚Äôt see any change. Each task‚Äôs HTML is already stored in the cache and as the cache hasn‚Äôt expired the old content is still shown. A common workaround for this problem is to add a version number to the cache key.
 /app/views/projects/_project.html.erb
 &lt;% cache [''v1'', project] do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render project.tasks %&gt;
&lt;% end %&gt;
Now because we‚Äôve changed the cache key the cache will be expired and reloaded and we‚Äôll see the tasks displayed in an ordered list.
Dealing With Nested Caches
The problem with this approach is that every time we update the template we need to remember to change the version number so that the cache key changes and the changes are picked up. This isn‚Äôt difficult but things can get quickly out of hand if we have nested fragment caches. For example let‚Äôs say that we want to fragment-cache the tasks partial as well to give us a little extra performance.
 /app/views/tasks/_task.html.erb
 &lt;% cache [''v1'', task] do %&gt;
 &lt;%= task.name %&gt;
 &lt;%= link_to "edit", edit_task_path(task) %&gt;
&lt;% end %&gt;
When we do this we‚Äôll need to update the version number in the project partial‚Äôs cache key too so that the whole cache is expired. If we update the task partial now, say to change the link‚Äôs text from ‚Äúedit‚Äù to ‚Äúrename‚Äù, we‚Äôll have to update the version number as well. We won‚Äôt see this change when we reload the page, however, unless we also change the version number in the projects partial as well. Once we‚Äôve changed both the change will be shown.
Using The Cache Digest Gem
Even though this has worked it‚Äôs annoying to have to remember to make this change every time we change a template and this is where the Cache Digests gem comes in useful. This functionality will be available by default in Rails 4 but has been extracted out into a gem so that we can use it in Rails 3 projects. This gem works by including a digest in the fragment cache keys that is based on the templates. This means that if the template changes a new cache key is generated and that cache will expire. We‚Äôll try this gem in our application. As ever we use it by adding it to our gemfile then running bundle to install it.
 /Gemfile
 gem ''cache_digests''
Now it‚Äôs no longer necessary for us to keep track of a version number in our fragment caches and we can remove them from both the project and task partials. When we restart our application now then reload its home page a digest will be included in the cache key that represents the template. 
When we make a change to the projects template now and reload the page the change doesn‚Äôt seem to be picked up. The reason for this is that the cache digest gem doesn‚Äôt read the template file on every request as this would be inefficient. Instead it keeps its own local cache of the digest for each template path in memory and this is why our template change hasn‚Äôt been picked up. To get this working in development we‚Äôll need to restart our Rails app again. This normally isn‚Äôt a problem in production as when we deploy the new templates the application will be restarted anyway. When we reload the page now then changed template is picked up as the cache digest is now different.
One good thing about this feature is that it‚Äôs smart enough to detect dependencies. For example it knows that the projects template has a render call for the projects tasks and so if the tasks partial changes it needs to expire the projects cache.
That said we have to watch out for those cases where the dependency isn‚Äôt properly detected. For example we have an incomplete_tasks method on the Project model. If we use this in the project partial to render the incomplete tasks then change the tasks partial the change won‚Äôt be picked up as the dependency isn‚Äôt detected. It‚Äôs therefore a good idea to run a Rake task that the gem provides called cache_digests:nested_dependencies and pass it the path to the template.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "incomplete_tasks/incomplete_task"
 ]
 }
]
This tells us that it detected the project partial‚Äôs dependency, which is correct, but there is also an incomplete_task which isn‚Äôt correct, it should be task. This is something we need to change in order for the dependency to be picked up. In these cases its recommended to explicitly pass the partial option to render like this:
 /app/views/projects/_project.html.erb
 &lt;% cache project do %&gt;
 &lt;%= link_to project.name, edit_project_path(project) %&gt;
 &lt;%= render partial: ''tasks/task'', collection: project.incomplete_tasks %&gt;
&lt;% end %&gt;
Now when we run the Rake task the tasks dependency will be properly detected and the cache digest will be updated properly.
 
 $ rake cache_digests:nested_dependencies TEMPLATE=projects/index
[
 {
 "projects/project": [
 "tasks/task"
 ]
 }
]
There are further details about this in the gem‚Äôs README which is worth taking the time to read. It tells us what different render calls will be parsed correctly and which ones won‚Äôt and shows us another way to specify a template dependency if we‚Äôre rendering a partial in a helper method.
 
 
</div>', '2013-04-08 13:40:32.687000', 13, 'http://asciicasts.com/episodes/387-cache-digests', 'Cache Digests', '2013-04-08 13:40:32.687000')
  [1m[36mSQL (3.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 340:¬†DataTables¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 DataTables makes it easy to turn a plain HTML table into one with pagination, sorting and searching and all through JavaScript. In this episode we‚Äôll show you how to set it up and how to supply data from a Rails application. The page below displays a plain table of Product records. We‚Äôll add DataTables to it to improve it.
Adding DataTables to Our Application
We could just download the source code and use it in our Rails application but this is a little difficult to add to the asset pipeline as the code includes references to images with relative paths that we‚Äôd have to fix. Fortunately there‚Äôs a jquery-datatables-rails gem available that makes this much easier. We‚Äôll add this to the assets group in our gemfile. As this gem is updated fairly frequently and we want to use the latest version we‚Äôll use the github option and pass in the project‚Äôs path.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
end
The github option is new in Bundler 1.1. If you don‚Äôt have this you‚Äôll need to pass in the full git path instead. As always when adding a gem we‚Äôll need to run bundle to install it. We can now set DataTables up with the asset pipeline. First we‚Äôll go to the application.js file and add a call to dataTables/jquery.dataTables in the manifest.
 /app/assets/javascripts/application.js
 //= require jquery
//= require jquery_ujs
//= require dataTables/jquery.dataTables
//= require_tree .
There‚Äôs also come CSS we need to include so we‚Äôll need to do add something in application.css, too.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require dataTables/jquery.dataTables
 *= require_tree . 
*/
Adding DataTables to Our Table
Now that we have DataTables installed in our application we can use it to improve our table of products. The view code for that table is shown below and it‚Äôs fairly straightforward; all we do is loop through each product and render it in the table.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
&lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
&lt;% end %&gt;
To prepare this table for use with DataTables we need to wrap the header row inside a thead element and the body section in tbody. We also need a way to reference the the table from JavaScript so we‚Äôll give it an id.
 /app/views/products/index.html.erb
 Products
 
 Product Name
 Category
 Release Date
 Price
 
 &lt;% @products.each do |product| %&gt;
 
 &lt;%= link_to(product.name, product) %&gt;
 &lt;%= product.category %&gt;
 &lt;%= product.released_on.strftime("%B %e, %Y") %&gt;
 &lt;%= number_to_currency(product.price) %&gt;
 
 &lt;% end %&gt;
We can add DataTables to this table now with some CoffeeScript code. We‚Äôll do this in the products.js file. All we need to do is ensure that the DOM has loaded then call dataTable on our table.
 /app/assets/javascripts/products.js
 jQuery -&gt;
 $(''#products'').dataTable()
When we reload the page now our table looks quite different. We now have a DataTable with pagination, sorting and searching.
Customizing Our DataTable
There are many different options that we can pass to dataTable to change our table‚Äôs appearance and behaviour. For example setting sPaginationType will change the pagination; if we set this to full_numbers this will show a link for each page. The usage section of the DataTables site has a full list of the options we can use to customize our DataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
Reloading the page now will show the new pagination style.
Improving The Styling
The styling for our table isn‚Äôt perfect but we can change this. The DataTables homepage has an example table that‚Äôs nicely styled and we can use this with our table. The example table uses jQuery UI and this is included in the jquery-rails gem that‚Äôs in our gemfile. The CSS styling that we need for our table isn‚Äôt included, however, but there‚Äôs another gem, called jquery-ui-rails, that does. To add this we just include it in the gemfile and then run bundle again.
 /Gemfile
 group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer'', :platform =&gt; :ruby
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''jquery-datatables-rails'', github: ''rweng/jquery-datatables-rails''
 gem ''jquery-ui-rails''
end
To add the CSS to our application we need to add jquery.ui.core and jquery.ui.theme our application.css file. This will include the Smoothness theme. We also need to replace the DataTables CSS file with one that is designed for jQuery UI and one called demo_table_jui is provided under the src directory. We‚Äôll replace the jQuery.dataTables CSS with this.
 /app/assets/stylesheets/application.css
 /*
 * This is a manifest file that''ll automatically include all the stylesheets available in this directory
 * and any sub-directories. You''re free to add application-wide styles to this file and they''ll appear at
 * the top of the compiled file, but it''s generally better to create a new file per style scope.
 *= require_self
 *= require jquery.ui.core
 *= require jquery.ui.theme
 *= require dataTables/src/demo_table_jui
 *= require_tree . 
*/
We now need to add a bJQueryUI option to our call to dataTable.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
Finally we‚Äôll need to give our table a class of display.
 /app/views/products/index.html.erb
 
Reloading the page now shows a much better looking table.
Updating The Table With Data From The Server
Our table has pagination, sorting and searching but this currently all happens on the client. Our HTML page includes all the products from the database and DataTable handles choosing the ones to be displayed based on the page, sort order or search term chosen. This works well for small numbers of records, say up to 200, but if we have thousands or even millions of records we don‚Äôt want to send all this data to the client to be handled there. In these cases its better to send only the necessary records to the client and have DataTable communicate with the server when the selected page, sort field or search term changes. The Server-side processing page of the documentation tells us the parameters that are sent to the server and what to expect in response through JSON. We need to set up our Rails application to be able to deal with this and we‚Äôll need a way to do pagination on the server so we‚Äôll add will_paginate to our gemfile and run bundle again to install it.
 /Gemfile
 gem ''will_paginate''
We no longer want to display all the products in our template as these will now be fetched from the server. We‚Äôll need to define the URL that the relevant set of products can be fetched from and we‚Äôll put this in a data attribute on the opening table tag. We‚Äôll use the products_url and tell it to use the JSON format.
 /app/views/products/index.html.erb
 Products
"&gt;
 
 
 Product Name
 Category
 Release Date
 Price
 
 
 
 
In our Coffeescript file we‚Äôll need to add some more options to the call to dataTable to tell it to fetch data from the server.
 /app/assets/javascripts/products.js.coffee
 jQuery -&gt;
 $(''#products'').dataTable
 sPaginationType: "full_numbers"
 bJQueryUI: true
 bProcessing: true
 bServerSide: true
 sAjaxSource: $(''#products'').data(''source'')
The bProcessing option shows a ‚ÄúProcessing‚Äù message while fetching data from the server. Setting bServerSide to true means that the data will be fetched from the server. Finally sAjaxSource sets the URL that the data will be fetched from and we set this to the value in the data-source attribute that we defined in our table. DataTable will now trigger the ProductsController‚Äôs index action and it will expect a JSON response. We‚Äôll use a respond_to block to do this. The tricky part will be responding with the proper JSON. One option would be to use something like JBuilder or RABL, but these solutions can get messy very quickly as there‚Äôs quite a lot of logic required to generate the correct response.
If the MVC structure of Rails ever feels limiting and doesn‚Äôt fit with what we‚Äôre trying to do there‚Äôs nothing wrong with creating a new class if it leads to cleaner code. This is the approach we‚Äôll take here. We‚Äôll create a new ProductsDatatable class to generate the JSON and we‚Äôll have it take a view context in its constructor so that it has access to helper methods. This makes it like a mini-presenter for a JSON response. We‚Äôll create this class in a new datatables directory under the app directory. There‚Äôs too much code in this class to show here, but you can find the whole thing on Github. We‚Äôll run through it quickly and show the most interesting parts.
The initializer takes a view context and assigns it to an instance variable. We delegate a few helper methods to this view so that we can conveniently call them from here. 
 /app/datatables/products_datatable.rb
 delegate :params, :h, :link_to, :number_to_currency, to: :@view
def initialize(view)
 @view = view
end
The as_json method is triggered behind the scenes by the render_json call in the controller. This will return all the data that DataTables expects including all the relevant rows from the database. This data comes from a data method and this method loops through each of the products and returns a two-dimensional array containing the information for each cell in the table.
 /app/datatables/products_datatable.rb
 def as_json(options = {})
 {
 sEcho: params[:sEcho].to_i,
 iTotalRecords: Product.count,
 iTotalDisplayRecords: products.total_entries,
 aaData: data
 }
end
private
def data
 products.map do |product|
 [
 link_to(product.name, product),
 h(product.category),
 h(product.released_on.strftime("%B %e, %Y")),
 number_to_currency(product.price)
 ]
 end
end
The products are fetched in a fetch_products method. This fetches the correct page of data in the correct order filtered by a search term if one is present. The search query itself is simple but we could expand on it, maybe by using a full-text search engine such as Sphinx or Solr. 
 /app/datatables/products_datatable.rb
 def fetch_products
 products = Product.order("#{sort_column} #{sort_direction}")
 products = products.page(page).per_page(per_page)
 if params[:sSearch].present?
 products = products.where("name like :search or category like :search", search: "%#{params[:sSearch]}%")
 end
 products
end
The rest of the class is made up of methods to help with sorting and pagination. Now that we have this class we can use it in our controller action.
 /app/controllers/products_controller.rb
 def index
 respond_to do |format|
 format.html
 format.json { render json: ProductsDatatable.new(view_context) }
 end
end
When we reload the page now (we may need to restart the server first) everything works much as it did before. We still have the same pagination, sorting and searching behaviour but now the data is being supplied by the Rails application instead of being loaded all in one go on the client. 
That‚Äôs it for our episode on DataTables. It does require some effort if you need server-side processing but the end result is well worth it. If you‚Äôre interested in an alternative solution where we create something similar from scratch take a look at episode 240.
 
 
 
 
 
 
 
 
 
</div>', '2013-04-08 13:40:32.716000', 13, 'http://asciicasts.com/episodes/340-datatables', 'DataTables', '2013-04-08 13:40:32.716000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 338:¬†Globalize3¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 Below is a page from a blogging application that shows a number of Article records. This application supports internationalization and allows the user to change the language that‚Äôs displayed via links at the top of the page.
Clicking the ‚ÄúWookieespeak‚Äù link changes the title at the top of the page but each article‚Äôs content is still displayed in English. How do we change the content from the database so that‚Äôs it‚Äôs displayed in the user‚Äôs preferred language?
Internationalization in Rails applications is usually done with YAML files. Under the /config/locales directory are one or more files that contain the translated texts for each language that the application supports. This approach was covered in detail in episode 138 and while it works well for static text it won‚Äôt help us display text from the database in different languages. To do this we need to store each translation in a database table and the Globalize3 gem makes doing this much easier. Globalize3 creates a separate table to store translations for each model that we use it with and it will switch to the proper translation depending on the user‚Äôs selected locale. To use this gem in our application we‚Äôll need to add it to the gemfile and then run bundle to install it.
 /Gemfile
 gem ''globalize3''
Now we can go to the model we want to translate and use the translates method to specify the names of the columns we want to be available in multiple languages, in our case the name and content columns in Article.
 /app/models/article.rb
 class Article &lt; ActiveRecord::Base
 translates :name, :content
end
We need to create a database table to store the translations. The gem‚Äôs README file says that we can use create_translation_table! inside the same migration where we create the table for the model but as we already have a articles table with data in it we‚Äôll use an alternative approach that uses a separate migration and which allows us to migrate the existing data. First we‚Äôll create a migration called create_article_translations in our application.
 
 $ rails g migration create_article_translations
We‚Äôll modify this migration based on what the README file tells us. We need to call create_translations_table! on the model we want to add translations to and pass in the names of the columns that we want to be translatable.
 /db/migrations/291204100000_create_article_translations.rb
 class CreateArticleTranslations &lt; ActiveRecord::Migration
 def up
 Article.create_translation_table!({
 name: :string,
 content: :text
 }, {
 migrate_data: true
 })
 end
 def down
 Article.drop_translation_table! migrate_data: true
 end
end
The data from these two columns will now be stored not in the articles table but instead in a new article_translations table. We‚Äôll need to migrate the database for these changes to take effect.
 
 $ rake db:migrate
We can demonstrate how this works in the Rails console. If we check the current locale we‚Äôll see that it‚Äôs at its default of English. Getting the first article‚Äôs name will fetch it from our new article_translations table.
 
 1.9.3-p125 :001 &gt; I18n.locale
 =&gt; :en 
1.9.3-p125 :002 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
If we change the locale to Wookieespeak and try to fetch the first article‚Äôs name we‚Äôll get nil as the translated text doesn‚Äôt exist.
 
 1.9.3-p125 :003 &gt; I18n.locale = :wk
 =&gt; :wk 
1.9.3-p125 :004 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 Article::Translation Load (0.3ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1 AND "article_translations"."locale" = ''wk'' LIMIT 1
 =&gt; nil
Globalize3 overrides both the getter and setter behaviour for the columns and scopes it to the current language. If we update the first article‚Äôs name while our locale is set to wk it will insert a record into the article_translations table for that locale and when we fetch the name again we‚Äôll see the value we entered.
 
 1.9.3-p125 :005 &gt; Article.first.update_attribute(:name, "Ahhyya")
1.9.3-p125 :006 &gt; Article.first.name
 Article Load (0.3ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Ahhyya"
Changing the locale back to English will show the English name again.
 
 1.9.3-p125 :007 &gt; I18n.locale = :en
 =&gt; :en 
1.9.3-p125 :008 &gt; Article.first.name
 Article Load (0.2ms) SELECT "articles".* FROM "articles" LIMIT 1
 Article::Translation Load (0.2ms) SELECT "article_translations".* FROM "article_translations" WHERE "article_translations"."article_id" = 1
 =&gt; "Superman"
Now we can see this in action on our site. We‚Äôll need to restart the server for the changes to be picked up but after we do the English version of the page should look the same as that data has been migrated over. If we look the page in Wookieespeak, though, the page will be almost blank.
The first article here has the name that we set in the console but all the other attributes that we set up to be translatable will be blank. We can, however, now edit one of these articles and set the translated text.
This article is now available in two languages and when we switch between them we‚Äôll see it displayed in the selected language. If we go back to the edit form the text fields will show the text for the selected language and we can click the links and swap between them to update the article in either language. If we change an attribute which isn‚Äôt set up for translation such as the author name it will be updated for all all languages as its value will still be stored in the articles table, not the article_translations table. 
Using a Fallback Language
Translating all the database records into both languages can be quite a task. As we saw before nil values will be returned for those attributes that haven‚Äôt been translated into the current language but we can provide a fallback language that will be shown when a translation doesn‚Äôt exist in the current language. To do this we just need to modify our application‚Äôs config file and add an i18n.fallbacks option.
 /config/application.rb
 config.i18n.fallbacks = true
With this in place any translations that aren‚Äôt specified in the current language will fall back to the default locale, in this case English. We‚Äôll need to restart our application for this change to be picked up but when we reload the page the translations that are missing in Wookieespeak are shown in English instead.
 
 
</div>', '2013-04-08 13:40:32.741000', 13, 'http://asciicasts.com/episodes/338-globalize3', 'Globalize3', '2013-04-08 13:40:32.741000')
  [1m[36mSQL (5.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 336:¬†Copycopter¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 As developers writing copy isn‚Äôt always our cup of tea. For example take the text at the top of the page below. Should it say ‚ÄúBrowse Our Products‚Äù, ‚ÄúProduct Listing‚Äù or maybe even ‚ÄúProducts‚Äù instead of ‚ÄúBrowse Products‚Äù as it does now? 
A client may want text changes made to this heading or to the description below it and this text isn‚Äôt that easy to change. It‚Äôs hard-coded into the view template and anyone who wants to change it will need to have access to the source code so that they can edit the template and then redeploy the application, just to change some text. It would be much easier if there was a simple admin interface where the client could go in and edit text like this and Copycopter does just this, providing an interface where clients can edit a Rails application‚Äôs text. Copycopter also comes with a Ruby gem which makes it easy to integrate into an application. This used to be a paid service but Thoughtbot have recently open-sourced it and made it free to use and in this episode we‚Äôll use it to make our headline and description editable.
Setting up a Copycopter Server
First we‚Äôll need to set up the Copycopter server. This is a complete Rails application that provides the interface for editing copy. This isn‚Äôt a mountable engine and it needs to be deployed and hosted separately from our Rails application. Heroku is a perfect fit for this and Copycopter will work on one dyno so we can host it for free here. If you don‚Äôt have a Heroku account it‚Äôs free to sign up. Once we‚Äôve done so we‚Äôll need to install the Heroku Toolbelt which provides a command-line interface for managing our apps. Once we‚Äôve downloaded and installed this we‚Äôll have access to a new heroku command in any terminal windows we open. We‚Äôll use this command now to log in to our Heroku account.
 
 $ heroku login
Enter your Heroku credentials.
Email: eifion@asciicasts.com
Password: 
Authentication successful.
Now that we‚Äôre authenticated we can deploy Copycopter Server to Heroku. The Github documentation has some instructions for going this and we‚Äôll follow these. First we need to clone the project to our local machine. 
 
 $ git clone git://github.com/copycopter/copycopter-server.git
We‚Äôll then move into its directory and begin to deploy it to Heroku. First we‚Äôll create a new Heroku application.
 
 $ cd copycopter-server/
$ heroku create --stack cedar
Depending on your setup you may see an error when you run this command. We can fix this by running bundle install. It‚Äôs best to run this without the test environment to reduce the number of test dependencies.
 
 $ bundle install --without=test
After doing this we should be able to run heroku create without any errors. We deploy to Heroku by using Git and we can deploy our app by running git push.
 
 $ git push heroku master
We can run database migrations on the server by running this command.
 
 $ heroku run rake db:migrate
When this finished we need to run heroku restart. We can now create a Copycopter project by running this command. (Obviously you‚Äôll need to change the values for the NAME, USERNAME and PASSWORD options for your own application.)
 
 $ heroku run rake copycopter:project NAME=Store USERNAME=eifion PASSWORD=secret
We can take a look at the site we‚Äôve just created by running heroku open which will open the app in a browser.
If we click on the ‚ÄúStore‚Äù link we‚Äôll be prompted for the username and password we used when we created the Copycopter project. After we‚Äôve entered these we‚Äôll be taken to the project‚Äôs page and told that we don‚Äôt have a Rails application for this project. The page gives us instructions for doing this: we just need to add a gem to our application‚Äôs gemfile and add an initializer to configure the Copycopter client.
Configuring Our Rails Application to use Copycopter
We‚Äôll use these instructions to add Copycopter to our Store application. First we‚Äôll add the gem to the gemflle then run bundle to install it.
 /Gemfile
 gem ''copycopter_client'', ''2.0.0''
Next we‚Äôll create the initializer. This contains the configuration code that will hook up our application to the Copycopter server that we deployed.
 /config/initializers/copycopter.rb
 CopycopterClient.configure do |config|
 config.api_key = ''f5a22cf0acffc7010db99951be3c5d0d''
 config.host = ''sharp-window-4901.herokuapp.com''
end
Now we can make the headline and description on our application‚Äôs home page editable through Copycopter. To do this we need to go the page‚Äôs template and replace each piece of text with a call to the t method and pass in a unique key to identify it, along with a default value for each item to act as a fallback in case it isn‚Äôt defined in Copycopter.
 /app/views/products/index.html.erb
 &lt;%= t "products.headline", default: "Browse Products" %&gt;
&lt;%= t ".tagline", default: "We have what you need at a great low price." %&gt;
The t method here is Rails‚Äô built-in internationalization method which means that we can also use Copycopter to internationalize a website. Note that for the tagline the identifier starts with a full stop. This makes it a relative key and so it will be prefixed with the path to the template which will make it unique to this template.
We‚Äôll need to restart our application‚Äôs server to load Copycopter. When we reload the page afterwards it should look exactly the same as each call to t uses the default values. When we visit our Copycopter server now, however, we‚Äôll see a search dialog that allows us to search for keys. If we search for ‚Äúheadline‚Äù we‚Äôll see the products.headline key listed. Clicking on this will take us to a page where we can edit the key‚Äôd text. We‚Äôll change ‚ÄúBrowse Products‚Äù to ‚ÄúBrowse Our Products‚Äù
We have the option to make the change a draft or publish it to the production environment. We‚Äôll keep it at ‚ÄúDraft‚Äù and save our changes. When we reload our application‚Äôs page now the text has changed.
We can change the tagline in the same way. This will have a key of products.index.tagline as we gave it a relative key in our app. We can add styling to the editable text through the editor and also set the text for different locales if we want to translate our app‚Äôs text into other languages. 
Finally it‚Äôs worth noting that one Copycopter server can manage multiple projects so if we have another site we can run heroku run rake copycopter:project again with a different project name. 
 
 
</div>', '2013-04-08 13:40:32.763000', 13, 'http://asciicasts.com/episodes/336-copycopter', 'Copycopter', '2013-04-08 13:40:32.763000')[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 334:¬†Compass &amp; CSS Sprites¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Compass makes it more convenient to generate stylesheets with SASS by providing useful mixins, functions and more. The new CompassRails gem makes it easier than ever to integrate it with Rails‚Äô asset pipeline. Below is a simplified version of the Railscasts site design. We‚Äôre going use Compass to improve the underlying styling for this application while maintaining the same look.
To add Compass to a Rails app we just need to add the CompassRails gem to the assets group in the gemfile and then run bundle.
 /Gemfile
 # Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
 gem ''compass-rails''
end
gem ''jquery-rails''
Next we‚Äôll need to rename our application.css file to application.css.scss. This turns it into a SASS-interpreted file and it‚Äôs necessary to do this so that we have a location where we can load Compass and share it across our application‚Äôs SASS files. Sprockets can‚Äôt give us this functionality so we‚Äôll remove its manifest from this file and instead use SASS to import the necessary files. Our application has a layout.css.scss file so we‚Äôll import that as well as the compass file.
 /app/assets/application.css.scss
 @import "compass";
@import "layout";
As we‚Äôve added a gem to our application we‚Äôll need to restart the server. When we reload the page after doing that our page looks just as it did before and that‚Äôs good. The only difference is that we can now use Compass to improve our SASS code.
Using Compass in Our Application
Adding the compass file to our application gives us access to Compass‚Äôs new functionality. Compass makes it easier to work with CSS3 and with it we can add CSS features without needing to specify browser vendor prefixes for gradients, box shadows or border radiuses. The Railscasts application uses a gradient and these are documented in the images section. We‚Äôll use Compass to improve the code in the navigation bar. This styling is handled by the layout file.
 /app/assets/stylesheets/layout.css.scss
 #nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
 .nav {
 float: right;
 padding-top: 2px;
 li {
 padding-left: 25px;
 font-size: 14px;
 color: #BBB;
 a { color: #FFF; }
 }
 }
}
In this file we define the gradients four times to allow for different vendor prefixes. With Compass we don‚Äôt need to do this. Instead we can use just one line of code.
 /app/assets/stylesheets/layout.css.scss
 @include background-image(linear-gradient(#5c5c5c, #111111));
This will generate all the browser-specific prefixes for us. When we reload the page now it still looks the same but if we look at the generated CSS we‚Äôll see the all the gradients that Compass has generated.
 /assets/application.css
 /* line 69, ../../app/assets/stylesheets/layout.css.scss */
#nav_bar {
 position: relative;
 padding: 8px 100px;
 margin-bottom: 15px;
 border-top: solid 1px #FFF;
 border-bottom: solid 3px #DE9F00;
 background-color: #333;
 background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #5c5c5c), color-stop(100%, #111111));
 background-image: -webkit-linear-gradient(#5c5c5c, #111111);
 background-image: -moz-linear-gradient(#5c5c5c, #111111);
 background-image: -o-linear-gradient(#5c5c5c, #111111);
 background-image: -ms-linear-gradient(#5c5c5c, #111111);
 background-image: linear-gradient(#5c5c5c, #111111);
}
Using CSS Sprites
If all we want from Compass are the CSS3 conveniences then we could use Bourbon instead as we showed in episode 330. Compass provides much more, though, including CSS sprites. CSS sprites are a technique for combining a number of small images into one larger image and then using CSS to show just a part of each image. On our page we have a row of icons that let you subscribe to Railscasts in a variety of ways. Each of these icons is a separate image which means that a separate HTTP request will be made to get each one. It‚Äôs good practice to reduce the number of requests that a page makes. It we merge all these icons into one file we can use CSS to display a selected part of that image for each icon.
CSS sprites can be a pain to implement manually but Compass makes it easy. The icons are currently being handled by calls to background-image.
 /app/assets/stylesheets/layout.css.scss
 #subscribe {
 position: absolute;
 bottom: 10px;
 right: 100px;
 li {
 position: relative;
 margin-left: 8px;
 font-size: 12px;
 }
 a {
 display: block;
 width: 34px;
 height: 34px;
 }
 .itunes { background-image: image-url("icons/itunes.png"); }
 .twitter { background-image: image-url("icons/twitter.png"); }
 .facebook { background-image: image-url("icons/facebook.png"); }
 .rss { background-image: image-url("icons/rss.png"); }
}
To use Compass‚Äôs sprites we first need to take all the images we want to combine and put them in the same directory. Ours are already in /app/assets/images/icons so we don‚Äôt need to do this. We can load the images into Compass by calling @import and passing in the path. 
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
This will load up all the images in that directory and make a single sprite image from them. There are couple of different ways that we can use this. The more manual approach is to replace the call to background-image for each icon.
 /app/assets/stylesheets/layout.css.scss
 .itunes { @include icons-sprite(itunes); }
.twitter { @include icons-sprite(twitter); }
.facebook { @include icons-sprite(facebook); }
.rss { @include icons-sprite(rss) }
Again the page looks the same when we reload it but all the icons are now merged down into a single image so that they can all be downloaded in a single request.
Compass provides a more convenient way to do this. Instead of loading the sprites individually into a separate CSS class we can do it all through Compass. We can remove the CSS for the four classes that represent the icons and then replace them with this.
 /app/assets/stylesheets/layout.css.scss
 @import "icons/*.png";
@include all-icons-sprites;
This will automatically make a separate CSS class for each of these images. We‚Äôll need to change the HTML so that it references them. Each icon is displayed in a list like this.
 /app/views/layouts/application.html.erb
 
We just need to prefix each class with the name of the directory, in this case icons, and a dash.
 /app/views/layouts/application.html.erb
 
The page still looks the same now but the generated CSS references the single image and uses background-position to show the relevant part of it for each icon.
 /assets/application.css
 /* line 66, icons/*.png */
.icons-sprite, .icons-facebook, .icons-itunes, .icons-rss, .icons-twitter {
 background: url(/assets/icons-s1286bd1660.png) no-repeat;
}
/* line 60, ../../../.rvm/gems/ruby-1.9.3-p125/gems/compass-0.12.1/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icons-facebook {
 background-position: 0 -102px;
}
There‚Äôs more information about sprites in the ‚ÄúSpriting With Compass‚Äù tutorial. 
Simple Horizontal Lists
All of Compass‚Äôs documentation is good and it‚Äôs well worth taking the time to browse through the Reference and Help sections to get an idea as to what else Compass provides. There are many useful utility functions and one of these makes it much easier to generate horizontal lists. Lists are often used for rendering navigation menus and we can use the horizontal-list mixin to simplify this. The Railscasts site has a .horizontal CSS class which does just that and its SASS code looks like this:
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal { list-style: none;
 margin: 0;
 padding: 0;
 li {
 margin: 0;
 padding: 0;
 float: left;
 }
}
We can replace this with a call to that mixin.
 /app/assets/stylesheets/layout.css.scss
 ul.horizontal {
 @include horizontal-list;
}
Each horizontal list on the page is still rendered horizontally now, although we may need to adjust the margins or padding a little for each one.
Compass Reset
Compass Reset is another useful feature. Browsers have different default values for sizing and spacing different elements. Compass Reset will set everything to zero so that we can build styles back up consistently across different browsers. To use it we just need to import it in our application.css.scss file.
 /app/assets/stylesheets/application.css.scss
 @import "compass";
@import "compass/reset";
@import "layout";
This is one of the few compass commands that will insert CSS into our layout so we need to be aware of this when using it. With it in place the ‚ÄúWelcome‚Äù text which is in an h1 element is much smaller.
Most sites will look worse after the Reset CSS is added as most designs rely on the browsers‚Äô default styles to some degree. With the Reset in place, though, we can now build the styles up in a way that‚Äôs consistent across different browsers. For example we can now specifically declare how we want h1 elements to be rendered.
 /app/assets/stylesheets/layout.css.scss
 h1 {
 font-size: 28px;
 font-weight: bold;
 margin: 18px 0;
}
Now our page looks like it did before.
CSS Resets aren‚Äôt a good thing all the time, but if it‚Äôs important that your design is consistent across browsers then it‚Äôs worth considering using one. For an alternative to Compass Reset take a look at normalize.css. This sets defaults that are closer to the browsers‚Äô defaults which means that we don‚Äôt need to rebuild every element up from scratch. 
Further Reading
That‚Äôs it for this episode. There are a number of features we haven‚Äôt covered so be sure to take a look at the web site for more information. One part of Compass that we haven‚Äôt covered is the blueprint module. This is an entire CSS framework for building grid-based designs. It‚Äôs also worth reading the README for the CompassRails for some alternative approaches to integrating them together. If you‚Äôre using an earlier version of Rails there‚Äôs some useful information there on getting it working with CompassRails. 
Although Compass is a large framework it is very modular. This means that we can include just the parts we need for our application.
 
 
</div>', '2013-04-08 13:40:32.786000', 13, 'http://asciicasts.com/episodes/334-compass-css-sprites', 'Compass &amp;amp; CSS Sprites', '2013-04-08 13:40:32.786000')
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 332:¬†Refinery CMS Basics¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 
Let‚Äôs say that a client asks us to build them a site for a piano store. This site will be called Piano Plus and will have information about the store, a page where users can browse through the store‚Äôs stock of pianos and also one that shows the store‚Äôs location. There‚Äôs not much user interaction on the site but the owners would like to be able to edit the content of each page. This is a perfect case for a Content Management System so in this episode and its related pro episode we‚Äôll build this site using Refinery CMS. This is an excellent CMS which uses Rails engines, which makes it very modular. Thanks to the way Refinery is written we can either create a new Rails application with or add it to an existing app. 
Installing Refinery
Refinery depends on ImageMagick so we‚Äôll need to install that first. On OS X the easiest way to do this is through Homebrew. With it all we need to do is run the following command:
 
 $ brew install imagemagick
Now we can install the Refinery gem.
 
 $ gem install refinerycms
This gem has a number of dependencies and make take a while to install. Once it has we can create a new Refinery application by running the refinerycms command, passing it the name of our application.
 
 $ refinerycms piano_plus
This will generate a full Rails application, add Refinery to it, and run its migrations. When it finishes it will give us some instructions on what to do next which is to move into our new app‚Äôs directory and start up the server.
 
 $ cd piano_plus/
$ rails s
Getting Started With Refinery
We can take a look at our application in the browser now. The first time we do this we‚Äôll be taken to a registration page as there aren‚Äôt any users yet. We‚Äôll use this page to register an user called admin.
After we‚Äôve registered we‚Äôll be taken to the Refinery dashboard. This shows us the latest activity and has links for performing various tasks.
There are also some tabs at the top of the main section. These take us to pages that will help up manage various parts of our CMS such as the users and pages. Clicking the small tab on the right allows us to reorder these tabs. We‚Äôll mostly be working with pages so we‚Äôll take a look at that first.
Refinery sets up a few pages for us by default: a home page, an about us page and a page to handle 404 errors. We can edit a page by clicking the edit icon ; this takes us to a page where we can edit that page‚Äôs content. By default a page has two sections: ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù but we can customize these if we want to. Refinery gives us a rich-text editor for editing the content of each section. There‚Äôs also an ‚Äúadvanced‚Äù section at the bottom of the page that gives us options for changing various aspects of the page.
Let‚Äôs take a look at the actual application now. We can do this by clicking the orange button at the top left of each page. 
We can see the content of the page now but there‚Äôs no styling at all. This is good as it gives us complete control over how our site looks to the end user. 
Changing Settings and Adding CSS
Next we‚Äôll add some CSS to our application and change some settings such as the company name. A Refinery application‚Äôs structure should look familiar as it‚Äôs essentially a Rails application with a few Refinery extras thrown in. If we look at the routes file we‚Äôll see that it mounts the Refinery engine at the root path.
 /config/routes.rb
 # This line mounts Refinery''s routes at the root of your application.
 # This means, any requests to the root URL of your application will go to Refinery::PagesController#home.
 # If you would like to change where this extension is mounted, simply change the :at option to something different.
 #
 # We ask that you don''t use the :as option here, as Refinery relies on it being the default of "refinery"
 mount Refinery::Core::Engine, :at =&gt; ''/''
If we want to configure how Refinery works we need to look in the /config/initializers/refinery directory where there are a number of files for changing various settings. Each configuration option in these files is nicely documented in comments so it‚Äôs worth spending a little time reading through them to get an idea as to what can be configured. We want to change the site‚Äôs name and this option is defined in the core.rb file so we‚Äôll uncomment this option and change it.
 /config/initializers/refinery/core.rb
 # Site name
config.site_name = "Piano Plus"
As this setting is in an initializer we‚Äôll need to restart the server for it to be picked up. After we do that and reload the page we‚Äôll see the changed name in the header and footer of the page.
Next we‚Äôll add some styling to the page. It‚Äôs structured with a header section, containing an image, a page section containing the body of the page and a side_body section which contains the sidebar. Our application has an application.css file in the /app/assets/stylesheets directory which behaves in the same way as it would in a normal Rails application. We‚Äôll create a layout.css.scss file in the same directory and put our styles there. When we reload the page now it looks much better.
Next we‚Äôll edit the home page. We‚Äôll add a heading in an h2 element and a paragraph of lorem text. Below that we‚Äôll add another paragraph with two short pieces of text. These will should be links but the pages they will link to don‚Äôt yet exist. We‚Äôll use the style menu to set the font size of this last paragraph to large. We want an image on the page, too. The file is on our computer and Refinery will let us upload an image and then resize it. We‚Äôll choose the medium resize option and float the image left then place it near the top of the page by dragging it into place.
If we‚Äôre ever unsure about the HTML source code that‚Äôs being generated we can click the HTML button and view the raw code. We can also edit it if the WYSIWYG editor isn‚Äôt generating the exact code that we want. We don‚Äôt want anything in the sidebar on this page so we‚Äôll edit the Side Body section to remove the text there. Once we‚Äôve done that we‚Äôll save the page and take a look at it in the site.
This page is looking good now although we have had to make a few CSS tweaks. It‚Äôs almost complete but we want to add a red banner section near the top. Before we do that we‚Äôll add the Store Location page. We‚Äôll do this in the admin section again. First we‚Äôll delete the ‚ÄúAbout‚Äù page as we won‚Äôt be using it then we‚Äôll add a new page that we‚Äôll call ‚ÄúStore Location‚Äù. We want to display a map on this page so we‚Äôll click the HTML button and enter the following snippet for displaying a Google map on the page. 
 html
 Store Location
We‚Äôll also add some text to the sidebar on this page containing ‚ÄúContact Us‚Äù information before we save it. We want our home page to link to this new page so we‚Äôll go back into its editor, select the ‚ÄúStore Location‚Äù text, click the ‚ÄúAdd Link‚Äù button then add a link to our new page. We now have a link to our new page on the home page and the ‚ÄúStore Locator‚Äù page has the map and the contact information.
Adding Custom Sections
Next we‚Äôll add a red banner to the top of the home page. This will have some text and an image and appear above the main body of the page. We want this to be in a separate section but we only have the ‚ÄúBody‚Äù and ‚ÄúSide Body‚Äù sections at the moment. We could add this new banner into the sidebar but it‚Äôs not where it‚Äôs really meant to be so instead we‚Äôll add a new section. There‚Äôs a configuration option in Refinery that determines whether new sections can be added or not. Its default value is false so we‚Äôll need to change it.
 /config/initializers/refinery/pages.rb
 # Configure whether to allow adding new page parts
# config.new_page_parts = true
As we‚Äôve changed an initializer we‚Äôll need to restart the server again. Once we‚Äôve done so when we visit the edit page for the home page (or any other page) we‚Äôll see some new buttons that will allow us to add or remove sections. We‚Äôll use these to delete the Side Body section, as we don‚Äôt use it on this page, and add a new section called ‚ÄúBanner‚Äù. We‚Äôll also need to click the reorder button to make sure that that ‚ÄúBanner‚Äù section appears after the ‚ÄúBody‚Äù section. If you‚Äôre using a version of Refinery earlier than 2.0.2 then you might see an see error when you do this. In this case you can add a new page part manually through the console like this:
 console
 &gt;&gt; Refinery::Page.find(1).parts.create! "Banner"
Our page now has a ‚ÄúBanner‚Äù section and we can now add the content we want in the banner to it then save the page.
We‚Äôve already added some CSS for this section so when we switch to the home page we‚Äôll see our new banner already styled. If we want to see the page without Refinery‚Äôs bar at the top we‚Äôll need to log out first.
We can now browse around our site just like our customers would. To log back in to Refinery we just need to add /refinery to the URL and we‚Äôll be taken to the login page.
There‚Äôs one more section of the site we need to add: the ‚ÄúBrowse Pianos‚Äù page. We don‚Äôt be doing that in this episode, though. While we could just make a static page that lists the available pianos it would be better to store this information in a database. To do that we‚Äôll need to extend Refinery by creating our own engine. We‚Äôll cover this in this week‚Äôs pro episode.
 
 
</div>', '2013-04-08 13:40:32.836000', 13, 'http://asciicasts.com/episodes/332-refinery-cms-basics', 'Refinery CMS Basics', '2013-04-08 13:40:32.836000')[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 330:¬†Better SASS With Bourbon¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 If you‚Äôre tired of typing vendor-specific prefixes for CSS properties you should take a look at the Bourbon library which includes several SASS mixins and functions to make working with CSS more convenient. In this episode we‚Äôll show you how to use it in a Rails application.
Adding Bourbon to a Rails Application
The application we‚Äôll be working with is shown below. Its design needs some work so we‚Äôll add Bourbon to the app and use some of its features to improve the way the page looks.
Installing Bourbon is easy. All we need to do is add it to the gemfile and run bundle.
/Gemfile
source ''https://rubygems.org''
gem ''rails'', ''3.2.2''
# Bundle edge Rails instead:
# gem ''rails'', :git =&gt; ''git://github.com/rails/rails.git''
gem ''sqlite3''
# Gems used only for assets and not required
# in production environments by default.
group :assets do
 gem ''sass-rails'', ''~&gt; 3.2.3''
 gem ''coffee-rails'', ''~&gt; 3.2.1''
 # See https://github.com/sstephenson/execjs#readme for more supported runtimes
 # gem ''therubyracer''
 gem ''uglifier'', ''&gt;= 1.0.3''
end
gem ''jquery-rails''
gem ''bourbon''
To use Bourbon with Rails‚Äô asset pipeline we‚Äôll need to change the way that the default application.css file works. By default this file will use a Sprockets manifest to load each of the other stylesheet assets. The problem with this is that Sprockets compiles each SASS file into CSS individually which makes it difficult to share the Bourbon mixins across the SASS files. To fix this we can use SASS to load all the scss files instead of Sprockets.
We‚Äôll need to rename our the application.css file to application.css.scss, then we can then remove the Sprockets manifest and use SASS‚Äôs @import command to pull in the files that we want to include. For now we‚Äôll just include the bourbon file provided by the gem.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
We‚Äôll need to restart the Rails server for these changes to be picked up. After we‚Äôve done that when we reload the page all the styling has gone.
If we look at the /assets/application.css file in the browser we‚Äôll see that it‚Äôs blank. Bourbon doesn‚Äôt add any CSS to our application directly, it just makes it more convenient for us to add our own CSS through SASS. It‚Äôs still up to us to write all the CSS we need for our application so we‚Äôll put the layout and project files back in application.css.scss. We set up these CSS files earlier but now we‚Äôll be able to use Bourbon in them.
/app/assets/stylesheets/application.css.scss
@import "bourbon";
@import "layout";
@import "projects";
When we reload the page now it will bring us back to the design we had earlier.
Modifying The Header
The first improvement we‚Äôll make to our design is to change the font. The page currently uses the browser‚Äôs default font, which is usually Times New Roman. Bourbon includes a font-family add-on which provides aeveral variables for setting the type of font. These include fallback fonts for when the first font required isn‚Äôt available. We‚Äôll use one of these to set the body‚Äôs font.
/app/assets/stylesheets/layout.css.scss
body {
 margin: 0;
 padding: 0;
 background-color: #FFF;
 font-size: 14px;
 font-family: $verdana;
}
Next we‚Äôll add a gradient to the header. Bourbon provides a linear-gradient module and we can use this to add a gradient and set its colours. We‚Äôll add a gradient that fades from light grey to a darker grey. Note that we haven‚Äôt set a direction for the gradient; this means that the default value of top will be used.
/app/assets/stylesheets/layout.css.scss
#header {
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
}
A default background colour is included in linear-gradient so we‚Äôve removed the background-color property from the header. We also want a drop shadow under the header and Bourbon provides a mixin for adding these. We can use this in a similar way to the box-shadow CSS3 property but the mixin will generate all the vendor-specific prefixes for us. We‚Äôll add a black shadow with no offset and with a six pixel shadow with a three pixel spread.
/app/assets/stylesheets/layout.css.scss
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 @include linear-gradient(#777, #444);
 @include box-shadow(0 0 6px 3px #000);
}
When we reload the page now these changes can be seen.
Modifying The Items
Next we‚Äôll make some changes to the list of items. First we‚Äôll add rounded corners to the box that surrounds each project. Needless to say Bourbon has a border-radius module to do just this. The project-specific styling is in a projects.css.scss file so we‚Äôll make this change there and add a six pixel radius.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Next we‚Äôll change the way that the background colour of each item changes when we hover over it. Instead of it changing immediately we‚Äôd like it to fade in to that colour. We can use transitions to do this, passing in the attribute we want to change, the time it should take to do the change and the easing effect.
/app/assets/stylesheets/projects.css.scss
.project {
 border: solid 1px #AAA;
 margin: 20px 0;
 padding: 7px 12px;
 @include border-radius(6px);
 @include transition(all, 500ms, ease-in-out);
 
 &amp;:hover { background-color: #F8FCCF; }
 
 h2 {
 margin: 0;
 a { text-decoration: none; }
 }
}
Now the background colour will fade in over half a second when we hover over a project and fade out over the same time when the cursor moves out.
The last change we‚Äôll make to this page is to improve the ‚ÄúNew Project‚Äù link. We‚Äôd like it to look more like a button instead and Bourbon includes a buttons add-on that we can use to make different styles of button. Our link has a new_project class so we‚Äôll use that to style it and turn the link into a simple green button.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
}
When we reload the page now we‚Äôll see the rounded corners and the styled link. (You‚Äôll have to take the background colour fade on trust.)
The button has inherited some attributes from the anchor tag such as the underlined text and we want it to be a little larger. We‚Äôll add some more CSS to do this.
/app/assets/stylesheets/projects.css.scss
.new_project {
 @include button(simple, #3FB344); 
 text-decoration: none;
 font-size: 16px;
}
We now have a nice button for adding a new project.
An Example Of The CSS That Bourbon Generates
Now that the page is looking better let‚Äôs look at the CSS that Bourbon has generated. We can‚Äôt show it all here as there‚Äôs a lot of it but as an example here‚Äôs the generated CSS for the header and we can see the code for the gradient that we added.
css
#header {
 background-color: #555;
 color: #FFF;
 padding: 15px 100px;
 font-size: 30px;
 font-weight: bold;
 background-color: #777777;
 background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #777777), color-stop(100%, #444444));
 background-image: -webkit-linear-gradient(top, #777777, #444444);
 background-image: -moz-linear-gradient(top, #777777, #444444);
 background-image: -ms-linear-gradient(top, #777777, #444444);
 background-image: -o-linear-gradient(top, #777777, #444444);
 background-image: linear-gradient(top, #777777, #444444);
 -webkit-box-shadow: 0 0 6px 3px black;
 -moz-box-shadow: 0 0 6px 3px black;
 box-shadow: 0 0 6px 3px black;
}
There‚Äôs a lot of code here that we‚Äôve not had to write manually thanks to Bourbon.
SASS also includes several functions that can help out with generating CSS when dealing with colour changes, variations and adjustments. There‚Äôs more information in episode 268 on what can be done with SASS alone.
 
 
</div>', '2013-04-08 13:40:32.865000', 13, 'http://asciicasts.com/episodes/330-better-sass-with-bourbon', 'Better SASS With Bourbon', '2013-04-08 13:40:32.865000')
  [1m[36m (0.0ms)[0m  [1mRELEASE SAVEPOINT active_record_1[0m
  [1m[35m (0.0ms)[0m  SAVEPOINT active_record_1
  [1m[36m (2.0ms)[0m  [1mUPDATE "atom_smasher_feeds" SET "url" = '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/current_episodes.xml', "updated_at" = '2013-04-08 13:40:32.891000' WHERE "atom_smasher_feeds"."id" = 13[0m
  [1m[35m (0.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36mAtomSmasher::Feed Load (2.0ms)[0m  [1mSELECT "atom_smasher_feeds".* FROM "atom_smasher_feeds" ORDER BY "atom_smasher_feeds"."id" DESC LIMIT 1[0m
  [1m[35mAtomSmasher::Post Load (5.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/396-importing-csv-and-excel' LIMIT 1
  [1m[36mAtomSmasher::Post Load (6.0ms)[0m  [1mSELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 AND "atom_smasher_posts"."link" = 'http://asciicasts.com/episodes/393-guest-user-record' LIMIT 1[0m
  [1m[35m (1.0ms)[0m  SAVEPOINT active_record_1
  [1m[36mSQL (4.0ms)[0m  [1mINSERT INTO "atom_smasher_posts" ("content", "created_at", "feed_id", "link", "title", "updated_at") VALUES ('<div>
 
 396:¬†Importing CSV and Excel¬†
 
 
 (view original Railscast)
 
 Other formats: 
 
 
 
 
 
 In episode 362 we showed how to export database records to a CSV or Excel file. Since then there have been a number of requests for an episode showing how to import records from these types of files so that‚Äôs what we‚Äôll cover in this episode.
We‚Äôll do this by adding a form to the bottom of this page that will allow the user to upload a file containing records. When the form is submitted the file will be parsed and the records added to the database. We‚Äôll add the form at the bottom of the view template
 
 
 /app/views/products/index.html.erb
 Import Products
&lt;%= form_tag import_products_path, multipart: true do %&gt;
 &lt;%= file_field_tag :file %&gt;
 &lt;%= submit_tag "Import" %&gt;
&lt;% end %&gt;
We don‚Äôt have an object to handle the importing right now so we‚Äôve used form_tag instead of form_for. The form will be submitted to a new import action on the ProductsController and note that we‚Äôve set the multipart option so that the form can handle file uploads. We‚Äôll need to set up the new path in the routes file so we‚Äôll do that now.
 /config/routes.rb
 Store::Application.routes.draw do
 resources :products do
 collection { post :import }
 end
 root to: ''products#index''
end
Now in the ProductsController we‚Äôll add the import action. This should take the uploaded file then import its data into our database. The file will be uploaded into a file parameter and Rails will store the uploaded file temporarily in the file system while it‚Äôs processed. This means that we don‚Äôt have to user CarrierWave or Paperclip to work with uploaded files. In this action we‚Äôll pass the uploaded file to a new import method on the Product model then redirect back to the home page.
 /app/controllers/products_controller.rb
 def import
 Product.import(params[:file])
 redirect_to root_url, notice: "Products imported."
end
Importing CSV Data
Now we can focus on the model and the import behaviour. We already have some code in this class from the for exporting CSV data so we‚Äôll focus on importing CSV data before we try handling Excel files. Our app‚Äôs config file already has the line require ''csv'' so that we can use Ruby‚Äôs built-in CSV library. 
 /app/models.product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 Product.create! row.to_hash
 end
end
The import method is shown above. In it we call CSV.foreach and pass it the path to the file. This will yield to the block for each line of data that‚Äôs found. We‚Äôve used the headers option so the first line of data will be expected to hold each column‚Äôs name which will be used to name the data. We then create a product by passing row.to_hash. As long as the column names map to attributes in Product a new record will be created for each row. We‚Äôll try this with a simple CSV file.
 products.csv
 name,price,released_on
Christmas Music Album,12.99,2012-12-06
Unicorn Action Figure,5.85,2012-12-06
When we upload this file through our new form and submit it the new products appear in the list.
Modifying Existing Records
It would be useful if we had an id column in our data that could be used to update an existing record instead of adding a new one. This way we could download an CSV file, modify the products in it then upload it to change multiple products at once. If we download our existing products we‚Äôll end up with this CSV data.
 products.csv
 id,name,released_on,price,created_at,updated_at
4,Acoustic Guitar,2012-12-26,1025.0,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
5,Agricola,2012-10-31,45.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
6,Christmas Music Album,2012-12-06,12.99,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
2,Red Shirt,2012-10-04,12.49,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
1,Settlers of Catan,2012-10-01,34.95,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
3,Technodrome,2012-12-22,27.99,2012-12-29 18:23:40 UTC,2012-12-29 18:23:40 UTC
7,Unicorn Action Figure,2012-12-06,5.85,2012-12-29 20:55:29 UTC,2012-12-29 20:55:29 UTC
To get this to work we‚Äôll need to change the way that the products are imported. Instead of creating a product for each row of data we‚Äôll try to find one based on the value in the id column. We‚Äôll use find_by_id so that nil is returned if a matching record isn‚Äôt found and in this case we‚Äôll create a new record. Next we‚Äôll set the product‚Äôs attributes based on the data in the row and as this might include attributes we don‚Äôt want to set attributes for such as the id we‚Äôll update off the only the attributes that are listed in the model‚Äôs attr_accessible list.
 /app/models/product.rb
 def self.import(file)
 CSV.foreach(file.path, headers: true) do |row|
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
We‚Äôve edited our CSV file now and altered a couple of the products‚Äô names. If we upload this file we should see these changes but no new products added.
This has worked. The two products we renamed have their new names showing and no new records have been added.
Importing Excel Spreadsheets
Now that we have CSV files working how can we import an Excel file? There are several gems available that handle importing from Excel; in this episode we‚Äôll use the Roo gem as it provides a standardized interface for accessing a variety of spreadsheet formats, including Excel and CSV. The gem is installed in the usual way, by adding it to our application‚Äôs gemfile and running bundle.
 /Gemfile
 gem ''roo''
It‚Äôs also necessary to modify our application‚Äôs config file to require the iconv library. Unfortunately doing this adds some warnings every time we start up our Rails application so hopefully the gem will move away from using this soon.
 /config/application.rb
 require ''iconv''
Now that we have Roo installed we can use it to import product records from a spreadsheet. The first thing we need to do is get a spreadsheet from Roo. Doing this can be a little complicated so we‚Äôll do it in a separate method that we‚Äôll call open_spreadsheet and write shortly. A Roo spreadsheet has a row method which returns an array of values from that row. The first row will contain the header details so we‚Äôll fetch that first. We‚Äôll then loop through the other rows and fetch each one‚Äôs data, calling last_row on our spreadsheet object to get the total number of rows.
Next comes the tricky part. Fetching each row returns an array of values but we need to convert that to a hash, with the header columns as the keys. To do this we create an array of the header and the current row and call transpose on that to create an array of arrays, each one of which contains the header name and the appropriate value for the current row. Finally we convert this to a hash which gives us an object similar to the one we got from the CSV library.
 /app/models/product.rb
 def self.import(file)
 spreadsheet = open_spreadsheet(file)
 header = spreadsheet.row(1)
 (2..spreadsheet.last_row).each do |i|
 row = Hash[[header, spreadsheet.row(i)].transpose]
 product = find_by_id(row["id"]) || new
 product.attributes = row.to_hash.slice(*accessible_attributes)
 product.save!
 end
end
Next we need to define open_spreadsheet method. This will build up a different Roo spreadsheet depending on the file extension. We use original_filename on the uploaded file because it‚Äôs stored in a temporary file which doesn‚Äôt have an extension. Note that the current master branch of Roo has the class names under a Roo namespace so that when a new version is released we‚Äôll need to use, for example, Roo::Excel instead of just Excel. The third option, :ignore, tells Roo not to raise an exception if the file extension doesn‚Äôt match the type.
 /app/models/product.rb
 def self.open_spreadsheet(file)
 case File.extname(file.original_filename)
 when ''.csv'' then Csv.new(file.path, nil, :ignore)
 when ''.xls'' then Excel.new(file.path, nil, :ignore)
 when ''.xlsx'' then Excelx.new(file.path, nil, :ignore)
 else raise "Unknown file type: #{file.original_filename}"
 end
end
We have an Excel file with the correct columns and a couple of product records in xlsx format so we‚Äôll upload it through our form and see if that works.
This works. The list now contains the new products from the Excel document. One issue with this solution is that it doesn‚Äôt like to import any files that we export from our application: an exception is raised when we try it. Files generated by Excel seem to import without any problems, however. 
Validating Data
This problem aside our import script is working well, but we aren‚Äôt validating the data that we import. Let‚Äôs say that we validate the presence of the price field and that one of the records in the spreadsheet is missing that field. How do we handle this situation? It‚Äôs a little difficult to adapt our solution to handle validations so if this is important it might be better to take a different approach. 
Here‚Äôs an example of what we might do. Instead of having the form displayed inline on the products listing page we can add it to a separate page where we can add instructions to tell the user which column names are required and the datatype they need to be. On this page we can validate the data and display the rows that failed validation so that we can fix these then try uploading the document again.
We don‚Äôt have time to build this solution in this episode but we‚Äôll walk you through it to show you how it works. On the products page we now have a link for uploading a product that points to the new_product_import_path. This is handled by a new ProductImportsController and we also have a new ProductImport model to handle the importing of products. Keeping this as a separate model allows us to use form_for inside our new templates.
 /app/controllers/product_imports_controller.rb
 class ProductImportsController &lt; ApplicationController
 def new
 @product_import = ProductImport.new
 end
 def create
 @product_import = ProductImport.new(params[:product_import])
 if @product_import.save
 redirect_to root_url, notice: "Imported products successfully."
 else
 render :new
 end
 end
end
We have a new template for uploading files that uses form_for so that we can easily display any validation errors just like we would with any other model. This model isn‚Äôt stored in the database, however, it‚Äôs a simple Ruby class. We use ActiveModel here to simulate ActiveRecord. When we try to save this model it will import the products and check to see that they‚Äôre all valid. If not one or more error messages will be shown. The importing itself works much the same way as the code we had before. The end result is that any validation errors that occur when we try to import the products are shown. For more information about this approach take a look at the source code for the completed app on Github.
 
 
</div>', '2013-04-08 13:40:33.798000', 13, 'http://asciicasts.com/episodes/396-importing-csv-and-excel', 'Importing CSV and Excel', '2013-04-08 13:40:33.798000')[0m
  [1m[35m (1.0ms)[0m  RELEASE SAVEPOINT active_record_1
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13[0m
  [1m[35mAtomSmasher::Post Load (6.0ms)[0m  SELECT "atom_smasher_posts".* FROM "atom_smasher_posts" WHERE "atom_smasher_posts"."feed_id" = 13 ORDER BY "atom_smasher_posts"."id" DESC LIMIT 1
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 13:42:53.175000', 'Atom Smasher', '2013-04-08 13:42:53.175000')
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:42:53.292000', '2013-04-08 13:42:53.292000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
Connecting to database specified by database.yml
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 13:45:06.442000', 'Atom Smasher', '2013-04-08 13:45:06.442000')
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:45:06.553000', '2013-04-08 13:45:06.553000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 13:46:24.446000', 'Atom Smasher', '2013-04-08 13:46:24.446000')
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:46:24.569000', '2013-04-08 13:46:24.569000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
Connecting to database specified by database.yml
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (9.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 13:52:04.861000', 'Atom Smasher', '2013-04-08 13:52:04.861000')
  [1m[36m (6.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 13:52:04.996000', '2013-04-08 13:52:04.996000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
Connecting to database specified by database.yml
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 14:12:10.709000', 'Atom Smasher', '2013-04-08 14:12:10.709000')
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 14:12:10.792000', '2013-04-08 14:12:10.792000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
Connecting to database specified by database.yml
  [1m[36m (20.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (3.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"
  [1m[36m (2.0ms)[0m  [1mSELECT "schema_migrations"."version" FROM "schema_migrations" [0m
Migrating to CreateUsers (20130408132820)
Migrating to CreateAtomSmasherFeeds (20130408141528)
  [1m[35m (1.0ms)[0m  SELECT sqlite_version(*)
  [1m[36m (5.0ms)[0m  [1mCREATE TABLE "atom_smasher_feeds" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "url" varchar(255), "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) [0m
ActiveRecord::JDBCError: [SQLITE_ERROR] SQL error or missing database (table "atom_smasher_feeds" already exists): CREATE TABLE "atom_smasher_feeds" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "url" varchar(255), "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) 
Connecting to database specified by database.yml
  [1m[36m (10.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (1.0ms)[0m  SELECT sqlite_version(*)
  [1m[36m (11.0ms)[0m  [1mCREATE TABLE "schema_migrations" ("version" varchar(255) NOT NULL) [0m
  [1m[35m (3.0ms)[0m  SELECT name, sql FROM sqlite_master WHERE tbl_name = "schema_migrations" AND type = 'index'
  [1m[36m (9.0ms)[0m  [1mCREATE UNIQUE INDEX "unique_schema_migrations" ON "schema_migrations" ("version")[0m
  [1m[35m (3.0ms)[0m  SELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_info"
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (2.0ms)[0m  SELECT "schema_migrations"."version" FROM "schema_migrations" 
Migrating to CreateUsers (20130408132820)
  [1m[36m (18.0ms)[0m  [1mCREATE TABLE "users" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(255), "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) [0m
  [1m[35m (3.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130408132820')
Migrating to CreateAtomSmasherFeeds (20130408141528)
  [1m[36m (9.0ms)[0m  [1mCREATE TABLE "atom_smasher_feeds" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "url" varchar(255), "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) [0m
  [1m[35m (2.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130408141528')
Migrating to CreateAtomSmasherPosts (20130408141529)
  [1m[36m (16.0ms)[0m  [1mCREATE TABLE "atom_smasher_posts" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "feed_id" integer, "content" text, "title" varchar(255), "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) [0m
  [1m[35m (3.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130408141529')
Migrating to AddLinkToAtomSmasherPosts (20130408141530)
  [1m[36m (18.0ms)[0m  [1mALTER TABLE "atom_smasher_posts" ADD "link" varchar(255)[0m
  [1m[35m (3.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130408141530')
Migrating to CreateAtomSmasherSubscriptions (20130408141531)
  [1m[36m (11.0ms)[0m  [1mCREATE TABLE "atom_smasher_subscriptions" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "reader_id" integer, "feed_id" integer, "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL) [0m
  [1m[35m (3.0ms)[0m  INSERT INTO "schema_migrations" ("version") VALUES ('20130408141531')
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "schema_migrations"[0m
  [1m[35m (2.0ms)[0m  SELECT "schema_migrations"."version" FROM "schema_migrations" 
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence'[0m
  [1m[35m (3.0ms)[0m  SELECT name, sql FROM sqlite_master WHERE tbl_name = "atom_smasher_feeds" AND type = 'index'
  [1m[36m (3.0ms)[0m  [1mSELECT name, sql FROM sqlite_master WHERE tbl_name = "atom_smasher_posts" AND type = 'index'[0m
  [1m[35m (3.0ms)[0m  SELECT name, sql FROM sqlite_master WHERE tbl_name = "atom_smasher_subscriptions" AND type = 'index'
  [1m[36m (3.0ms)[0m  [1mSELECT name, sql FROM sqlite_master WHERE tbl_name = "users" AND type = 'index'[0m
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 14:20:57.568000', 'Atom Smasher', '2013-04-08 14:20:57.568000')
  [1m[36m (7.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 14:20:57.713000', '2013-04-08 14:20:57.713000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
Connecting to database specified by database.yml
  [1m[36m (25.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
Connecting to database specified by database.yml
  [1m[36m (24.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
Connecting to database specified by database.yml
Connecting to database specified by database.yml
  [1m[36m (7.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (12.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 14:44:19.674000', 'Atom Smasher', '2013-04-08 14:44:19.674000')
  [1m[36m (6.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 14:44:19.864000', '2013-04-08 14:44:19.864000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 14:49:16.268000', 'Atom Smasher', '2013-04-08 14:49:16.268000')
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 14:49:16.432000', '2013-04-08 14:49:16.432000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_subscriptions"[0m
Connecting to database specified by database.yml
  [1m[36m (10.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (7.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 14:53:12.106000', 'Atom Smasher', '2013-04-08 14:53:12.106000')
  [1m[36m (6.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 14:53:12.262000', '2013-04-08 14:53:12.262000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36m (16.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_subscriptions"[0m
Connecting to database specified by database.yml
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 14:54:15.633000', 'Atom Smasher', '2013-04-08 14:54:15.633000')
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 14:54:15.727000', '2013-04-08 14:54:15.727000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_subscriptions"[0m
Connecting to database specified by database.yml
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 14:55:23.158000', 'Atom Smasher', '2013-04-08 14:55:23.158000')
  [1m[36m (3.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (3.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 14:55:23.241000', '2013-04-08 14:55:23.241000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_subscriptions"[0m
  [1m[35mSQL (4.0ms)[0m  INSERT INTO "atom_smasher_subscriptions" ("created_at", "feed_id", "reader_id", "updated_at") VALUES ('2013-04-08 14:55:23.518000', 6, 6, '2013-04-08 14:55:23.518000')
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_feeds" INNER JOIN "atom_smasher_subscriptions" ON "atom_smasher_feeds"."id" = "atom_smasher_subscriptions"."feed_id" WHERE "atom_smasher_subscriptions"."reader_id" = 6[0m
Connecting to database specified by database.yml
  [1m[36m (5.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "users"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "users" ("created_at", "name", "updated_at") VALUES ('2013-04-08 14:57:32.056000', 'Atom Smasher', '2013-04-08 14:57:32.056000')
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_feeds"[0m
  [1m[35mSQL (6.0ms)[0m  INSERT INTO "atom_smasher_feeds" ("created_at", "updated_at", "url") VALUES ('2013-04-08 14:57:32.214000', '2013-04-08 14:57:32.214000', '/Users/adalton/code/ihmc/metal/atom_smasher/spec/models/../fixtures/previous_episodes.xml')
  [1m[36m (4.0ms)[0m  [1mSELECT name FROM sqlite_master WHERE type = 'table' AND NOT name = 'sqlite_sequence' AND name = "atom_smasher_subscriptions"[0m
  [1m[35mSQL (5.0ms)[0m  INSERT INTO "atom_smasher_subscriptions" ("created_at", "feed_id", "reader_id", "updated_at") VALUES ('2013-04-08 14:57:32.448000', 7, 7, '2013-04-08 14:57:32.448000')
  [1m[36m (4.0ms)[0m  [1mSELECT COUNT(*) FROM "atom_smasher_feeds" INNER JOIN "atom_smasher_subscriptions" ON "atom_smasher_feeds"."id" = "atom_smasher_subscriptions"."feed_id" WHERE "atom_smasher_subscriptions"."reader_id" = 7[0m
